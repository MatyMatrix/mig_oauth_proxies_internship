{
  "test suite": {
    "name": "TA",
    "description": "JWT parameter JSON presence",
    "filter messages": true
  },
  "tests": [
    {
      "test": {
        "name": "Does the Trust Anchor's Entity configuration's constraints parameter contain the attribute 'max_path_length'",
        "description": "To accomplish this test, the Entity configuration of the TA is taken, the payload is decoded (Base64 encoding) and the presence of the constraints parameter is checked. It must contain the attribute max_path_length",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints.max_path_length",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the Entity's metadata contain the contacts parameter",
        "description": "In this test the Entity metadata are taken and the presence of the 'contacts' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.contacts",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the Entity's metadata contain the federation_fetch_endpoint parameter",
        "description": "In this test the Entity metadata are taken and the presence of the 'federation_fetch_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_fetch_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the Entity's metadata contain the federation_list_endpoint parameter",
        "description": "In this test the Entity metadata are taken and the presence of the 'federation_list_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_list_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the Entity's metadata contain the federation_resolve_endpoint parameter",
        "description": "In this test the Entity metadata are taken and the presence of the 'federation_resolve_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_resolve_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the Entity's metadata contain the federation_trust_mark_status_endpoint parameter",
        "description": "In this test the Entity metadata are taken and the presence of the 'federation_trust_mark_status_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_trust_mark_status_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the Entity's metadata contain the homepage_uri parameter",
        "description": "In this test the Entity metadata are taken and the presence of the 'homepage_uri' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.homepage_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the Entity's metadata contain the logo_uri parameter",
        "description": "In this test the Entity metadata are taken and the presence of the 'logo_uri' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.logo_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the Entity's metadata contain the organization_name parameter",
        "description": "In this test the Entity metadata are taken and the presence of the 'organization_name' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.organization_name",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the Entity's metadata contain the policy_uri parameter",
        "description": "In this test the Entity metadata are taken and the presence of the 'policy_uri' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.policy_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.logo_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the claims_parameter_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the claims_parameter_supported parameter inside the openid_provider type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.claims_parameter_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct token_endpoint_auth_methods_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_methods_supported parameter inside the openid_provider type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.token_endpoint_auth_methods_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct acr_values_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the acr_values_supported parameter inside the openid_provider type is checked. It must be a JSON object containing the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.acr_values_supported.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the authorization_response_iss_parameter_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the authorization_response_iss_parameter_supported parameter inside the openid_provider type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.authorization_response_iss_parameter_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct authorization_response_iss_parameter_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the authorization_response_iss_parameter_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.authorization_response_iss_parameter_supported.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct claims_parameter_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the claims_parameter_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.claims_parameter_supported.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the client_registration_types_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types_supported parameter inside the openid_provider type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.client_registration_types_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct client_registration_types_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the client_registration_types_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.client_registration_types_supported.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct code_challenge_methods_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the code_challenge_methods_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.code_challenge_methods_supported.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct grant_types_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.grant_types_supported.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_encryption_alg_values_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encryption_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_signing_alg_values_supported.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_signing_alg_values_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_signing_alg_values_supported.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the jwks parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the jwks parameter inside the openid_provider type is checked. It must contain the RP JWKS related to the OIDC Core operations",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the request_authentication_methods_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the request_authentication_methods_supported parameter inside the openid_provider type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_authentication_methods_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_authentication_methods_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_authentication_methods_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_authentication_methods_supported.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_authentication_signing_alg_values_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the request_authentication_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.request_authentication_signing_alg_values_supported.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the request_parameter_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the request_parameter_supported parameter inside the openid_provider type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_parameter_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_parameter_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_parameter_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_parameter_supported.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct response_modes_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_modes_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.response_modes_supported.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct response_types_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.response_types_supported.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct revocation_endpoint_auth_methods_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the revocation_endpoint_auth_methods_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.revocation_endpoint_auth_methods_supported.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct scopes_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the scopes_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.scopes_supported.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct subject_types_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the subject_types_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.subject_types_supported.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the token_endpoint_auth_methods_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the token_endpoint_auth_methods_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.token_endpoint_auth_methods_supported.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct token_endpoint_auth_signing_alg_values_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.token_endpoint_auth_signing_alg_values_supported.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_encryption_alg_values_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encryption_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encryption_alg_values_supported.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_encryption_enc_values_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encryption_enc_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encryption_enc_values_supported.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_signing_alg_values_supported parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_signing_alg_values_supported.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct client_registration_types parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types parameter inside the openid_relying_party type is checked. It must contain the key 'one_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.client_registration_types.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct grant_types parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.grant_types.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_encrypted_response_alg parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_encrypted_response_alg.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_encrypted_response_enc parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_enc parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_encrypted_response_enc.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_signed_response_alg parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_signed_response_alg.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct token_endpoint_auth_method parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_method parameter inside the openid_relying_party type is checked. It must contain the key 'one_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.token_endpoint_auth_method.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct userinfo_encrypted_response_alg parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_encrypted_response_alg.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain the userinfo_encrypted_response_enc parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_enc parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_encrypted_response_enc.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct userinfo_signed_response_alg parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_signed_response_alg.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct client_registration_types parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types parameter inside the intermediary type is checked. It must contain the key 'one_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.client_registration_types.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct grant_types parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types parameter inside the intermediary type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.grant_types.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_encrypted_response_alg parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter inside the intermediary type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encrypted_response_alg.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_encrypted_response_enc parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_enc parameter inside the intermediary type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encrypted_response_enc.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_signed_response_alg parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter inside the intermediary type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_signed_response_alg.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct token_endpoint_auth_method parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_method parameter inside the intermediary type is checked. It must contain the key 'one_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.token_endpoint_auth_method.one_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_encrypted_response_alg parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the intermediary type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encrypted_response_alg.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_encrypted_response_enc parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_enc parameter inside the intermediary type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encrypted_response_enc.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_signed_response_alg parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter inside the intermediary type is checked. It must contain the key 'subset_of'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_signed_response_alg.subset_of",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.logo_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  ]
}