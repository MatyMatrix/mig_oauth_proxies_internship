{
  "test suite": {
    "name": "TA",
    "description": "All the test available for this entity",
    "filter messages": true
  },
  "tests": [
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued intermediary Trust Mark contain the sa_profile claim",
        "description": "A Trust Mark issued by a TA for an SA is taken, decrypted and the presence of the sa_profile claim is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sa_profile",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the policy_uri claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "policy_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the policy_uri claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "policy_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the tos_uri claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "tos_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the tos_uri claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "tos_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the claims claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the claims claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "claims",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the claims claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the claims claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "claims",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the service_documentation claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "service_documentation",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the service_documentation claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "service_documentation",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration of a considered entity return a Federation Metadata in JOSE format when an HTTP GET request is made to its .well-known/openid-federation endpoint",
        "description": "The considered entity must have published its entity configuration in the .well-known/openid-federation endpoint. So in this test, an HTTP GET request is made to the entity's .well-known/openid-federation endpoint (appended to the URL which identifies the entity) and the response is analyzed. This response has to be the entity configuration of the entity and therefore a Federation Metadata in JOSE format (Content-Type: application/entity-statement+jwt)",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the resolve entity statement endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request containing the parameters 'sub', 'anchor' and 'type' is made to the entity's endpoint and an HTTP 200 OK response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Resolve Entity Statement response",
            "checks": [
              {
                "in": "body",
                "check regex": "[\\s*\"[^\"]*\"(?:,\\s*\"[^\"]*\")*\\s*\\]$",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the entity listing endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request to the entity's endpoint is done. A response containing a JSON list with the known Entity Identifiers is expected",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Listing response",
            "checks": [
              {
                "in": "body",
                "check regex": "\\[\\s*\"[^\"]*\"(?:,\\s*\"[^\"]*\")*\\s*\\]$",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA publish the federation public key history",
        "description": "An HTTP Get request is made to the TA's /.well-known/openid-federation-jwks endpoint and the answer is analyzed",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Public Keys History response",
            "checks": [
              {
                "in": "body",
                "check regex": "\\[\\s*\"[^\"]*\"(?:,\\s*\"[^\"]*\")*\\s*\\]$",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.iss",
                    "as": "conf_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.iss",
                    "contains": "conf_iss"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.iss",
                    "as": "conf_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.iss",
                    "contains": "conf_iss"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.iss",
                    "as": "conf_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.iss",
                    "contains": "conf_iss"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.iss",
                    "as": "conf_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.iss",
                    "contains": "conf_iss"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.iss",
                    "as": "conf_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.iss",
                    "contains": "conf_iss"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.iss",
                    "as": "conf_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.iss",
                    "contains": "conf_iss"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.iss",
                    "as": "conf_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.iss",
                    "contains": "conf_iss"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.iss",
                    "as": "conf_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.iss",
                    "contains": "conf_iss"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.iss",
                    "as": "conf_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.iss",
                    "contains": "conf_iss"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.iss",
                    "as": "conf_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.iss",
                    "contains": "conf_iss"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.iss",
                    "as": "conf_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.iss",
                    "contains": "conf_iss"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.iss",
                    "as": "conf_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.iss",
                    "contains": "conf_iss"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'sub' claim",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must identify the subject.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.sub",
                    "as": "conf_sub"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.sub",
                    "contains": "conf_sub"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'sub' claim",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must identify the subject.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.sub",
                    "as": "conf_sub"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.sub",
                    "contains": "conf_sub"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'sub' claim",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must identify the subject.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.sub",
                    "as": "conf_sub"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.sub",
                    "contains": "conf_sub"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'sub' claim",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must identify the subject.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.sub",
                    "as": "conf_sub"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.sub",
                    "contains": "conf_sub"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'sub' claim",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must identify the subject.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.sub",
                    "as": "conf_sub"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.sub",
                    "contains": "conf_sub"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'sub' claim",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must identify the subject.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.sub",
                    "as": "conf_sub"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.sub",
                    "contains": "conf_sub"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'sub' claim",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must identify the subject.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.sub",
                    "as": "conf_sub"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.sub",
                    "contains": "conf_sub"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'sub' claim",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must identify the subject.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.sub",
                    "as": "conf_sub"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.sub",
                    "contains": "conf_sub"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'sub' claim",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must identify the subject.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.sub",
                    "as": "conf_sub"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.sub",
                    "contains": "conf_sub"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'sub' claim",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must identify the subject.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.sub",
                    "as": "conf_sub"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.sub",
                    "contains": "conf_sub"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'sub' claim",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must identify the subject.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.sub",
                    "as": "conf_sub"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.sub",
                    "contains": "conf_sub"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'sub' claim",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must identify the subject.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "$.sub",
                    "as": "conf_sub"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "use variable": "true",
                    "in": "payload",
                    "check": "$.sub",
                    "contains": "conf_sub"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain not valid values for the id_token_signed_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter inside the openid_relying_party type is checked. The key 'one_of' must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_signed_response_alg.one_of",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain not valid values for the id_token_encrypted_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter inside the openid_relying_party type is checked. The key 'one_of' must not contain the value ['RSA_1_5']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_encrypted_response_alg.one_of",
                    "not contains": [
                      "RSA_1_5"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain not valid values in the userinfo_signed_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter inside the openid_relying_party type is checked. The key 'one_of' must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_signed_response_alg.one_of",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain not valid values for the userinfo_encrypted_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the openid_relying_party type is checked. The key 'one_of' must not contain the value ['RSA_1_5']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_encrypted_response_alg.one_of",
                    "not contains": [
                      "RSA_1_5"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain not valid values for the id_token_signed_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter inside the intermediary type is checked. The key 'one_of' must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_signed_response_alg.one_of",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain not valid value for the id_token_encrypted_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter inside the intermediary type is checked. The key 'one_of' must not contain the value ['RSA_1_5']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encrypted_response_alg.one_of",
                    "not contains": [
                      "RSA_1_5"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain not valid values for the userinfo_signed_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter inside the intermediary type is checked. The key 'one_of' must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_signed_response_alg.one_of",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain not valid values for the userinfo_encrypted_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the intermediary type is checked. The key 'one_of' must not contain the value ['RSA_1_5']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encrypted_response_alg.one_of",
                    "not contains": [
                      "RSA_1_5"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the organization_name claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the organization_name claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.organization_name",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the homepage_uri claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the homepage_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.homepage_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the policy_uri claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the policy_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.policy_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the logo_uri claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the logo_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.logo_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the contacts claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the contacts claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.contacts",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the federation_resolve_endpoint claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the federation_resolve_endpoint claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_resolve_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata contain the federation_fetch_endpoint parameter",
        "description": "In this test the TA metadata are taken and the presence of the 'federation_fetch_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_fetch_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata contain the federation_list_endpoint parameter",
        "description": "In this test the TA metadata are taken and the presence of the 'federation_list_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_list_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata contain the federation_trust_mark_status_endpoint parameter",
        "description": "In this test the TA metadata are taken and the presence of the 'federation_trust_mark_status_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_trust_mark_status_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Anchor's Entity configuration's constraints parameter contain the attribute 'max_path_length'",
        "description": "To accomplish this test, the Entity configuration of the TA is taken, the payload is decoded (Base64 encoding) and the presence of the constraints parameter is checked. It must contain the attribute max_path_length",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints.max_path_length",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the iss parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the sub parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the iat parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the exp parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the jwks parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the metadata parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the metadata parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's entity configuration contain the authority_hints parameter",
        "description": "To accomplish this test, the Entity configuration of the OP is taken, the payload is decoded (Base64 encoding) and the presence of the authority_hints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.authority_hints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain the trust_marks parameter",
        "description": "To accomplish this test, the Entity configuration is taken, the payload is decoded (Base64 encoding) and the presence of the trust_marks parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity configuration of the Trust Anchor contain the constraints parameter in its decoded payload",
        "description": "To accomplish this test, the Entity configuration of the TA is taken, the payload is decoded (Base64 encoding) and the presence of the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does TA's Entity configuration contain the trust_mark_issuers parameter",
        "description": "To accomplish this test, the Entity configuration of the TA is taken, the payload is decoded (Base64 encoding) and the presence of the trust_mark_issuers parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_mark_issuers",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain the jwks parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the jwks parameter inside the openid_relying_party type is checked. It must contain the RP JWKS related to the OIDC Core operations",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy_openid_relying_party.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain grant_types parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.grant_types",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain id_token_signed_response_alg parameter ",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_signed_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_encrypted_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_encrypted_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_encrypted_response_enc parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_enc parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_encrypted_response_enc",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct userinfo_signed_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_signed_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct userinfo_encrypted_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the openid_relying_party type is checked. It must contain one_of=[\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_encrypted_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain the userinfo_encrypted_response_enc parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_enc parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_encrypted_response_enc",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct token_endpoint_auth_method parameter ",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_method parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.token_endpoint_auth_method",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct client_registration_types parameter ",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.client_registration_types",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct redirect_uris parameter presence",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the redirect_uris parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.redirect_uris",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct client_id parameter presence",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_id parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.client_id",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct response_types parameter presence",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.response_types",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain the grant_types parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types parameter inside the intermediary type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.grant_types",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain the id_token_signed_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter inside the intermediary type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.id_token_signed_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain the id_token_encrypted_response_alg parameter.",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter inside the intermediary type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.id_token_encrypted_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain the id_token_encrypted_response_enc parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_enc parameter inside the intermediary type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.id_token_encrypted_response_enc\")",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain the userinfo_signed_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter inside the intermediary type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.userinfo_signed_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain the userinfo_encrypted_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the intermediary type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.userinfo_encrypted_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain the userinfo_encrypted_response_enc parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_enc parameter inside the intermediary type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.userinfo_encrypted_response_enc",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain the token_endpoint_auth_method parameter.",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_method parameter inside the intermediary type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.token_endpoint_auth_method",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain the client_registration_types parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types parameter inside the intermediary type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.client_registration_types",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct redirect_uris parameter presence",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the redirect_uris parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.redirect_uris",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct client_id parameter presence",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_id parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.client_id",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain the response_types parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types parameter inside the intermediary type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.openid_relying_party.response_types",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the jwks parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the jwks parameter inside the openid_provider type is checked. It must contain the RP JWKS related to the OIDC Core operations",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.openid_relying_party.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the revocation_endpoint_auth_methods_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the revocation_endpoint_auth_methods_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.revocation_endpoint_auth_methods_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the code_challenge_methods_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the code_challenge_methods_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.code_challenge_methods_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the scopes_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the scopes_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.scopes_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the response_types_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.response_types_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the response_modes_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_modes_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.response_modes_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the grant_types_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.grant_types_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the acr_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the acr_values_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.acr_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the subject_types_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the subject_types_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.subject_types_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the id_token_signing_alg_values_supported parameter.",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signing_alg_values_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.id_token_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the id_token_encryption_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encryption_alg_values_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encryption_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the id_token_encryption_enc_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encryption_enc_values_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.id_token_encryption_enc_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the userinfo_signing_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signing_alg_values_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.userinfo_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the userinfo_encryption_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encryption_alg_values_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.userinfo_encryption_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the userinfo_encryption_enc_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encryption_enc_values_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.userinfo_encryption_enc_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct token_endpoint_auth_methods_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_methods_supported parameter inside the openid_provider type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.openid_provider.token_endpoint_auth_methods_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the token_endpoint_auth_signing_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_signing_alg_values_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.token_endpoint_auth_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the claims_parameter_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the claims_parameter_supported parameter inside the openid_provider type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.claims_parameter_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the request_parameter_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the request_parameter_supported parameter inside the openid_provider type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_parameter_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the authorization_response_iss_parameter_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the authorization_response_iss_parameter_supported parameter inside the openid_provider type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.authorization_response_iss_parameter_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the client_registration_types_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types_supported parameter inside the openid_provider type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.client_registration_types_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the request_authentication_methods_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the request_authentication_methods_supported parameter inside the openid_provider type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_authentication_methods_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the request_authentication_signing_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the request_authentication_signing_alg_values_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.request_authentication_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the request_object_signing_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_object_signing_alg_values_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.request_object_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the issuer parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the issuer parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.issuer",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the authorization_endpoint parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the authorization_endpoint parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.authorization_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the token_endpoint parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the token_endpoint parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.token_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the userinfo_endpoint parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the userinfo_endpoint parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.userinfo_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the introspection_endpoint parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the introspection_endpoint parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.introspection_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the revocation_endpoint parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the revocation_endpoint parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.revocation_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct client_registration_types parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types parameter inside the intermediary type is checked. It must contain one_of=[\"automatic\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.client_registration_types",
                    "is subset of": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"automatic\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Configuration",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Configuration Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_TA"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_SA"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_AA"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_OP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_RP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_SA"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_AA"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_OP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_RP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain a correctly signed trust_marks",
        "description": "To accomplish this test, the Entity configuration is taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the /.well-known/openid-federation endpoint",
        "description": "In order to check the presence and correctness of the /.well-known/openid-federation endpoint, an HTTP GET request to the entity's endpoint is done and its entity configuration is expected as response.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the EC response",
        "description": "In this test a correct request to the entity's /.well-known/openid-federation endpoint is made and the response is analyzed. It must be an HTTP 200 OK response",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the resolve entity statement endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request containing the parameters 'sub', 'anchor' and 'type' is made to the entity's endpoint and an HTTP 200 OK response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Resolve Entity Statement response",
            "checks": [
              {
                "in": "body",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued intermediary Trust Mark contain the sa_profile claim",
        "description": "A Trust Mark issued by a TA for an SA is taken, decrypted and the presence of the sa_profile claim is checked. It must be a string.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \":  \"object \", \"properties \": { \"sa_profile\": { \"type \":  \"string \"}}, \"required \": [ \"sa_profile \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued intermediary Trust Mark contain a correct sa_profile claim",
        "description": "A Trust Mark issued for an SA is taken, decrypted and the value of the sa_profile claim can be 'full' or 'light'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"sa_profile\": { \"type \": \u00a0\"string \", \"enum \": [ \"full \", \u00a0\"light \"]}}, \"required \": [ \"sa_profile \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the policy_uri claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"policy_uri\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"policy_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the policy_uri claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"policy_uri\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"policy_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the policy_uri claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"policy_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"policy_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the policy_uri claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"policy_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"policy_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the tos_uri claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"tos_uri\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"tos_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the tos_uri claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"tos_uri\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"tos_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the tos_uri claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"tos_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"tos_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the tos_uri claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"tos_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"tos_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct claims claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the value of the claims claim is checked to be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"claims\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"claims\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct claims claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the value of the claims claim is checked to be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"claims\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"claims\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) is taken and the service_documentation claim is checked to be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"service_documentation\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"service_documentation\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) is taken and the service_documentation claim is checked to be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"service_documentation\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"service_documentation\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) is taken and the service_documentation claim is checked to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"service_documentation\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"service_documentation\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) is taken and the service_documentation claim is checked to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"service_documentation\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"service_documentation\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct Content-Type in the EC response",
        "description": "In this test a correct request to the entity's /.well-known/openid-federation endpoint is made and the response is analyzed. It must have a Content-Type parameter set to application/entity-statement+jwt",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "checks": [
              {
                "in": "head",
                "url decode": false,
                "is": "application/entity-statement+jwt",
                "check param": "Content-Type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'openid_relying_party'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "openid_relying_party.*(\\n.*)+\"openid_relying_party\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'openid_provider'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "openid_provider.*(\\n.*)+\"openid_provider\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'federation_entity'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "federation_entity.*(\\n.*)+\"federation_entity\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'oauth_authorization_server'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "oauth_authorization_server.*(\\n.*)+\"oauth_authorization_server\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one  'oauth_resource'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "oauth_resource.*(\\n.*)+\"oauth_resource\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct iss parameter value",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked. It must identify the issuing entity.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is": "X_url_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration OP contain a correct sub parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the sub parameter is checked. Its value must be equal to the one in the iss parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is": "X_url_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the iss claim has to uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "iss",
                    "as": "valid_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "use variable": "true",
                        "in": "payload",
                        "check": "iss",
                        "contains": "valid_iss"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the iss claim has to uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "iss",
                    "as": "valid_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "use variable": "true",
                        "in": "payload",
                        "check": "iss",
                        "contains": "valid_iss"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the iss claim has to uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "iss",
                    "as": "valid_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "use variable": "true",
                        "in": "payload",
                        "check": "iss",
                        "contains": "valid_iss"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the iss claim has to uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "iss",
                    "as": "valid_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "use variable": "true",
                        "in": "payload",
                        "check": "iss",
                        "contains": "valid_iss"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the iss claim has to uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "iss",
                    "as": "valid_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "use variable": "true",
                        "in": "payload",
                        "check": "iss",
                        "contains": "valid_iss"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the iss claim has to uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "iss",
                    "as": "valid_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "use variable": "true",
                        "in": "payload",
                        "check": "iss",
                        "contains": "valid_iss"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the iss claim has to uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "iss",
                    "as": "valid_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "use variable": "true",
                        "in": "payload",
                        "check": "iss",
                        "contains": "valid_iss"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the iss claim has to uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "iss",
                    "as": "valid_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "use variable": "true",
                        "in": "payload",
                        "check": "iss",
                        "contains": "valid_iss"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the iss claim has to uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "iss",
                    "as": "valid_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "use variable": "true",
                        "in": "payload",
                        "check": "iss",
                        "contains": "valid_iss"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the iss claim has to uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "iss",
                    "as": "valid_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "use variable": "true",
                        "in": "payload",
                        "check": "iss",
                        "contains": "valid_iss"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the iss claim has to uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "iss",
                    "as": "valid_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "use variable": "true",
                        "in": "payload",
                        "check": "iss",
                        "contains": "valid_iss"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity Statement's JWT payload contain a correct 'iss' claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the iss claim has to uniquely identifies the issuer.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "iss",
                    "as": "valid_iss"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "use variable": "true",
                        "in": "payload",
                        "check": "iss",
                        "contains": "valid_iss"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the sub claim has to uniquely identifies the subject.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "iss",
                    "as": "valid_sub"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "use variable": "true",
                        "in": "payload",
                        "check": "sub",
                        "contains": "valid_sub"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the sub claim has to uniquely identifies the subject.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "iss",
                    "as": "valid_sub"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "use variable": "true",
                        "in": "payload",
                        "check": "sub",
                        "contains": "valid_sub"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the sub claim has to uniquely identifies the subject.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "iss",
                    "as": "valid_sub"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "use variable": "true",
                        "in": "payload",
                        "check": "sub",
                        "contains": "valid_sub"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the sub claim has to uniquely identifies the subject.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "iss",
                    "as": "valid_sub"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "use variable": "true",
                        "in": "payload",
                        "check": "sub",
                        "contains": "valid_sub"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the sub claim has to uniquely identifies the subject.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "iss",
                    "as": "valid_sub"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "use variable": "true",
                        "in": "payload",
                        "check": "sub",
                        "contains": "valid_sub"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the sub claim has to uniquely identifies the subject.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "iss",
                    "as": "valid_sub"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "use variable": "true",
                        "in": "payload",
                        "check": "sub",
                        "contains": "valid_sub"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the sub claim has to uniquely identifies the subject.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "iss",
                    "as": "valid_sub"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "use variable": "true",
                        "in": "payload",
                        "check": "sub",
                        "contains": "valid_sub"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the sub claim has to uniquely identifies the subject.",
        "type": "active",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "session": "s1",
            "action": "start"
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Configuration response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "edits": [
                  {
                    "jwt from": "payload",
                    "jwt save": "iss",
                    "as": "valid_sub"
                  }
                ]
              }
            ]
          },
          {
            "action": "intercept",
            "from session": "s1",
            "then": "forward",
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "use variable": "true",
                        "in": "payload",
                        "check": "sub",
                        "contains": "valid_sub"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the entity listing endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request to the entity's endpoint is done. A response containing a JSON list with the known Entity Identifiers is expected",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Listing response",
            "checks": [
              {
                "in": "url",
                "is present": true,
                "check": "HTTP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct iss parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct iss parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct sub parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the sub parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct sub parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the sub parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain a correct iat parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain a correct exp parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct jwks parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the jwks parameter is checked. It must be JSON Object that contains keys, which is a JSON Array, which contains at least kty, which is a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct jwks parameter type for IT",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the jwks parameter is checked. It must contain at least KID.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}, \"kid\":{\"type\":\"string\"}},\"required\":[\"kty\", \"kid\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain a JSON Object",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"metadata\": {\"type\": \"object\"}}, \"required\": [\"metadata\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only allowed types",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "json schema compliant": "{\"type\": \"object\",\"anyOf\": [{\"required\": [\"openid_relying_party\"]},{\"required\": [\"openid_provider\"]},{\"required\": [\"federation_entity\"]},{\"required\": [\"oauth_authorization_server\"]},{\"required\": [\"oauth_resource\"]}],\"properties\": {\"openid_relying_party\":{\"type\":\"object\"},\"openid_provider\":{\"type\":\"object\"},\"federation_entity\":{\"type\":\"object\"},\"oauth_authorization_server\":{\"type\":\"object\"},\"oauth_resource\":{\"type\":\"object\"}}, \"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's entity configuration contain a correct authority_hints parameter",
        "description": "To accomplish this test, the Entity configuration of the OP is taken, the payload is decoded (Base64 encoding) and the authority_hints parameter is checked, it must be an array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"authority_hints\": {\"type\": \"array\", \"items\":{\"type\":\"string\"}}}, \"required\": [\"authority_hints\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's entity configuration contain a correct authority_hints parameter",
        "description": "To accomplish this test, the Entity configuration of the OP is taken, the payload is decoded (Base64 encoding) and the authority_hints parameter is checked, it must be an array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"authority_hints\": {\"type\": \"array\", \"items\":{\"type\":\"uri\"}}}, \"required\": [\"authority_hints\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain a correct trust_marks parameter",
        "description": "To accomplish this test, the Entity configuration is taken, the payload is decoded (Base64 encoding) and the type of the trust_marks parameter is checked. It must be an array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"trust_marks\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"array\"}}}, \"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain a correct trust_marks parameter value",
        "description": "To accomplish this test, the Entity configuration is taken, the payload is decoded (Base64 encoding) and the type of the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct organization_name claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the organization_name claim in the 'federation_entity' entity type is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"organization_name\": {\"type\": \"string\"}},\"required\": [\"organization_name\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct homepage_uri claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the homepage_uri claim in the 'federation_entity' entity type is checked. It must be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"homepage_uri\": {\"type\": \"string\",\"format\": \"uri\"}},\"required\": [\"homepage_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct policy_uri claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the policy_uri claim in the 'federation_entity' entity type is checked. It must be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"policy_uri\": {\"type\": \"string\",\"format\": \"uri\"}},\"required\": [\"policy_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain correct type logo_uri claim",
        "description": "In this test the metadata in the TA Entity Configuration are taken and the value of the logo_uri claim in the 'federation_entity' entity type is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"logo_uri\":{\"type\":\"string\"}},\"required\":[\"logo_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain a correct logo_uri claim",
        "description": "In this test the metadata in the TA Entity Configuration are taken and the value of the logo_uri claim in the 'federation_entity' entity type is an HTTPS URL with an .svg file",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"logo_uri\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://.*\\\\.svg$\"}},\"required\":[\"logo_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain correct type contacts claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the value of the contacts claim in the 'federation_entity' entity type is a JSON Array of String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"contacts\":{\"type\":\"array\", \"items\":{\"type\":\"string\"}}},\"required\":[\"contacts\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct federation_resolve_endpoint claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the federation_resolve_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_resolve_endpoint\": {\"type\": \"string\",\"format\": \"uri\", \"pattern\": \"^https://[^#]+$\"}},\"required\": [\"federation_resolve_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct federation_resolve_endpoint claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the federation_resolve_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL that ends with /trust_mark_status.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_resolve_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://.*/resolve\"}},\"required\": [\"federation_resolve_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA metadata contain at least federation_entity",
        "description": "In this test the TA metadata in the TA Entity Configuration are taken and the presence of the federation_entity is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_entity\": {\"type\": \"object\"}},\"required\": [\"federation_entity\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA metadata contain the correct federation_fetch_endpoint claim type",
        "description": "In this test the TA metadata in the TA Entity Configuration are taken and the presence of the federation_fetch_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_fetch_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://\"}},\"required\": [\"federation_fetch_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA metadata contain the correct federation_fetch_endpoint claim type",
        "description": "In this test the TA metadata in the TA Entity Configuration are taken and the presence of the federation_fetch_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL that ends with /trust_mark_status.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_fetch_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://.*/fetch\"}},\"required\": [\"federation_fetch_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA metadata contain the correct federation_list_endpoint claim type",
        "description": "In this test the TA metadata in the TA Entity Configuration are taken and the presence of the federation_list_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_trust_mark_status_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://\"}},\"required\": [\"federation_trust_mark_status_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA metadata contain the correct federation_list_endpoint claim type",
        "description": "In this test the TA metadata in the TA Entity Configuration are taken and the presence of the federation_list_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL that ends with /list.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_trust_mark_status_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://.*/list\"}},\"required\": [\"federation_trust_mark_status_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA metadata contain the correct federation_trust_mark_status_endpoint claim type",
        "description": "In this test the TA metadata in the TA Entity Configuration are taken and the presence of the federation_trust_mark_status_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_trust_mark_status_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\"}},\"required\": [\"federation_trust_mark_status_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA metadata contain the correct federation_trust_mark_status_endpoint claim type",
        "description": "In this test the TA metadata in the TA Entity Configuration are taken and the presence of the federation_trust_mark_status_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL that ends with /trust_mark_status.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_trust_mark_status_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://.*/trust_mark_status\"}},\"required\": [\"federation_trust_mark_status_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Anchor's Entity configuration contain a constraints parameter valued as a JSON Object with a max_path_length claim",
        "description": "To accomplish this test, the Entity configuration of the TA is taken, the payload is decoded (Base64 encoding) and the presence of the constraints parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"constraints\": {\"type\": \"object\", \"properties\": {\"max_path_length\": {}}, \"required\": [\"max_path_length\"]}, \"required\": [\"constraints\"]}}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does TA's Entity configuration's trust_mark_issuers parameter contain a JSON Object of JSON Array",
        "description": "To accomplish this test, the Entity configuration of the TA is taken, the payload is decoded (Base64 encoding) and the trust_mark_issuers parameter must be a JSON Object of JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"trust_mark_issuers\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"array\"}}}, \"required\": [\"trust_mark_issuers\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object and MUST contain [\"openid_relying_party\", \"openid_provider\"]",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\", \"properties\": { \"openid_relying_party\": { \"type\": \"object\", \"additionalProperties\": true }, \"openid_provider\": { \"type\": \"object\", \"additionalProperties\": true } }, \"required\": [\"openid_relying_party\", \"openid_provider\"] } }, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object and MUST contain [\"openid_relying_party\", \"openid_provider\"]",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\", \"properties\": { \"openid_relying_party\": { \"type\": \"object\", \"additionalProperties\": true }, \"openid_provider\": { \"type\": \"object\", \"additionalProperties\": true } }, \"required\": [\"openid_relying_party\", \"openid_provider\"] } }, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object and MUST contain [\"openid_relying_party\", \"openid_provider\"]",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\", \"properties\": { \"openid_relying_party\": { \"type\": \"object\", \"additionalProperties\": true }, \"openid_provider\": { \"type\": \"object\", \"additionalProperties\": true } }, \"required\": [\"openid_relying_party\", \"openid_provider\"] } }, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object and MUST contain [\"openid_relying_party\", \"openid_provider\"]",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\", \"properties\": { \"openid_relying_party\": { \"type\": \"object\", \"additionalProperties\": true }, \"openid_provider\": { \"type\": \"object\", \"additionalProperties\": true } }, \"required\": [\"openid_relying_party\", \"openid_provider\"] } }, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain the jwks parameter as JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the jwks parameter inside the openid_relying_party type is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct grant_types parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types parameter type. Must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.grant_types",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct grant_types parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types parameter inside the openid_relying_party type is checked. It must contain: 'superset_of':[authorization_code], 'subset_of: [authorization_code, refresh_token]' and 'essential':true",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.grant_types",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"authorization_code\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"authorization_code\",\"refresh_token\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_signed_response_alg parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_signed_response_alg",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_signed_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter inside the openid_relying_party type is checked. It must contain one_of=[\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_signed_response_alg",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_encrypted_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_encrypted_response_alg",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_encrypted_response_alg parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter inside the openid_relying_party type is checked. It must contain one_of=[\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_encrypted_response_alg",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_encrypted_response_enc parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_enc parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_encrypted_response_enc",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_encrypted_response_enc parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_enc parameter inside the openid_relying_party type is checked. It must contain the key 'one_of' valued with ['A128CBC-HS256', 'A256CBC-HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_encrypted_response_enc",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"A128CBC-HS256\", \"A128CBC-HS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct userinfo_signed_response_alg parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_signed_response_alg",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct userinfo_signed_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter inside the openid_relying_party type is checked. It must contain one_of=[\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_signed_response_alg",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct userinfo_encrypted_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the openid_relying_party type is checked. It must contain one_of=[\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_encrypted_response_alg",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct userinfo_encrypted_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the openid_relying_party type is checked. It must contain one_of=[\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_encrypted_response_alg",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain the userinfo_encrypted_response_enc parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_enc parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_encrypted_response_enc",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain the userinfo_encrypted_response_enc parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_enc parameter inside the openid_relying_party type is checked. It must contain  'one_of': ['A128CBC-HS256', 'A256CBC-HS512'] and 'essential':true",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_encrypted_response_enc",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"A128CBC-HS256\", \"A128CBC-HS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct token_endpoint_auth_method parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_method parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.token_endpoint_auth_method",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct token_endpoint_auth_method parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_method parameter inside the openid_relying_party type is checked. It must contain the key 'one_of' valued with ['private_key']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.token_endpoint_auth_method",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"private_key_jwt\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct client_registration_types parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.client_registration_types",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct client_registration_types parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types parameter inside the openid_relying_party type is checked. It must contain 'one_of': ['automatic'] and 'essential':true",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.client_registration_types",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"automatic\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct redirect_uris parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the redirect_uris parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.redirect_uris",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct redirect_uris parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the redirect_uris parameter inside the openid_relying_party type is checked. It must contain {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.redirect_uris",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct client_id parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_id parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.client_id",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct client_id parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_id parameter inside the openid_relying_party type is checked. It must contain {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.client_id",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct response_types parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.response_types",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct response_types parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types parameter inside the openid_relying_party type is checked. It must contain the key 'value'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.response_types",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"value\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"code\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"value\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct grant_types parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types parameter inside the intermediary type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.grant_types",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct grant_types parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types parameter inside the intermediary type is checked. It must contain the key 'subset_of' values with ['authorization_code', 'refresh_token']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.grant_types",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"authorization_code\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"authorization_code\",\"refresh_token\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_signed_response_alg parameter type.",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter inside the intermediary type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_signed_response_alg",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_signed_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter inside the intermediary type is checked. It must contain one_of=[\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_signed_response_alg",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_encrypted_response_alg parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter inside the intermediary type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encrypted_response_alg",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_encrypted_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter inside the intermediary type is checked. It must contain one_of=[\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encrypted_response_alg",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_encrypted_response_enc parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_enc parameter inside the intermediary type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encrypted_response_enc",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_encrypted_response_enc parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_enc parameter inside the intermediary type is checked. It must contain one_of=[\"A128CBC-HS256\", \"A128CBC-HS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encrypted_response_enc",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"A128CBC-HS256\", \"A128CBC-HS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_signed_response_alg parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter inside the intermediary type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_signed_response_alg",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_signed_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter inside the intermediary type is checked. It must contain one_of=[\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_signed_response_alg",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_encrypted_response_alg parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the intermediary type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encrypted_response_alg",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_encrypted_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the intermediary type is checked. It must contain one_of=[\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encrypted_response_alg",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_encrypted_response_enc parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_enc parameter inside the intermediary type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encrypted_response_enc",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_encrypted_response_enc parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_enc parameter inside the intermediary type is checked. It must contain one_of=[\"A128CBC-HS256\", \"A128CBC-HS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encrypted_response_enc",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"A128CBC-HS256\", \"A128CBC-HS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct token_endpoint_auth_method parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_method parameter inside the intermediary type is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.token_endpoint_auth_method",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct token_endpoint_auth_method parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_method parameter inside the intermediary type is checked. It must contain one_of=[\"private_key_jwt\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.token_endpoint_auth_method",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"private_key_jwt\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct client_registration_types parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types parameter inside the intermediary type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata_policy.intermediary.client_registration_types",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct redirect_uris parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the redirect_uris parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.redirect_uris",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct redirect_uris parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the redirect_uris parameter inside the openid_relying_party type is checked. It must contain {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.redirect_uris",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct client_id parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_id parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.client_id",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct client_id parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_id parameter inside the openid_relying_party type is checked. It must contain {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.client_id",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct response_types parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types parameter inside the intermediary type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.response_types",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct response_types parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types parameter inside the intermediary type is checked. It must contain the key 'value' with value 'code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.response_types",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"value\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"code\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"value\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the correct jwks parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the jwks parameter inside the openid_provider type is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct revocation_endpoint_auth_methods_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the revocation_endpoint_auth_methods_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.revocation_endpoint_auth_methods_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct revocation_endpoint_auth_methods_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the revocation_endpoint_auth_methods_supported parameter inside the openid_provider type is checked. It must contain subset_of=[\"private_key_jwt\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.revocation_endpoint_auth_methods_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"private_key_jwt\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct code_challenge_methods_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the code_challenge_methods_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.code_challenge_methods_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct code_challenge_methods_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the code_challenge_methods_supported parameter inside the openid_provider type is checked. It must contain subset_of=[\"S256\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.code_challenge_methods_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"S256\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct scopes_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the scopes_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.scopes_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct scopes_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the scopes_supported parameter inside the openid_provider type is checked. It must contain superset_of=[\"openid\", \"offline_access\"] AND subset_of=[\"openid\", \"offline_access\", \"profile\", \"email\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.scopes_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"openid\",\"offline_access\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"openid\",\"offline_access\",\"profile\",\"email\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct response_types_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.response_types_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct response_types_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types_supported parameter inside the openid_provider type is checked. It must contain subset_of=[\"code\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.response_types_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"const\": [\"code\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct response_modes_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_modes_supported parameter inside the openid_provider type is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.response_modes_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct response_modes_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_modes_supported parameter inside the openid_provider type is checked. It must contain superset_of=[\"form_post\", \"query\"] AND subset_of=[\"form_post\", \"query\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.response_modes_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"form_post\",\"query\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"form_post\",\"query\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct grant_types_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.grant_types_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct grant_types_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types_supported parameter inside the openid_provider type is checked. It must contain superset_of=[\"refresh_token\", \"authorization_code\"] AND subset_of=[\"refresh_token\", \"authorization_code\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.grant_types_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"refresh_token\",\"authorization_code\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"refresh_token\",\"authorization_code\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct acr_values_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the acr_values_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.acr_values_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct acr_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the acr_values_supported parameter inside the openid_provider type is checked. It must contain superset_of=[\"https://www.spid.gov.it/SpidL1\", \"https://www.spid.gov.it/SpidL2\"] AND subset_of=[\"https://www.spid.gov.it/SpidL1\", \"https://www.spid.gov.it/SpidL2\", \"https://www.spid.gov.it/SpidL3\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.acr_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"https://www.spid.gov.it/SpidL1\",\"https://www.spid.gov.it/SpidL2\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"https://www.spid.gov.it/SpidL1\",\"https://www.spid.gov.it/SpidL2\", \"https://www.spid.gov.it/SpidL3\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct subject_types_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the subject_types_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.subject_types_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct subject_types_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the subject_types_supported parameter inside the openid_provider type is checked. It must contain subset_of=[\"pairwise\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.subject_types_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"const\": [\"pairwise\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_signing_alg_values_supported parameter type.",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signing_alg_values_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_signing_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain superset_of=[\"RS256\", \"RS512\"], subset_of=[\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\",\"RS512\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\",\"RS512\", \"ES256\", \"ES512\", \"PS256\",\"PS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain not valid values for the id_token_signing_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signing_alg_values_supported parameter inside the openid_provider type is checked. The keys must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata_policy.intermediary.id_token_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"not\": {\"contains\": {\"enum\": [\"none\",\"HS256\",\"HS384\",\"HS512\"]}}},\"subset_of\": {\"not\": {\"contains\": {\"enum\": [\"none\",\"HS256\",\"HS384\",\"HS512\"]}}}},\"required\": [\"superset_of\",\"subset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_encryption_alg_values_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encryption_alg_values_supported parameter inside the openid_provider type is checked. Must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata_policy.intermediary.id_token_encryption_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_encryption_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encryption_alg_values_supported parameter inside the openid_provider type is checked. Must contain superset_of=[\"RSA-OAEP\", \"RSA-OAEP-256\"], subset_of=[\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata_policy.intermediary.id_token_encryption_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RSA-OAEP\",\"RSA-OAEP-256\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RSA-OAEP\",\"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_encryption_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encryption_alg_values_supported parameter inside the openid_provider type is checked. Must not contain the value ['RSA_1_5']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata_policy.intermediary.id_token_encryption_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"not\": {\"contains\": {\"enum\": [\"RSA_1_5\"]}}},\"subset_of\": {\"not\": {\"contains\": {\"enum\": [\"RSA_1_5\"]}}}},\"required\": [\"superset_of\",\"subset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_encryption_enc_values_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encryption_enc_values_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encryption_enc_values_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_encryption_enc_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encryption_enc_values_supported parameter inside the openid_provider type is checked. It must contain superset_of=[\"A128CBC-HS256\", \"A128CBC-HS512\"], subset_of=[\"A128CBC-HS256\", \"A128CBC-HS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encryption_enc_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"A128CBC-HS256\",\"A128CBC-HS512\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"A128CBC-HS256\",\"A128CBC-HS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_signing_alg_values_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signing_alg_values_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_signing_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain superset_of=[\"RS256\", \"RS512\"], subset_of=[\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\",\"RS512\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\",\"RS512\", \"ES256\", \"ES512\", \"PS256\",\"PS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain not valid values for the userinfo_signing_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signing_alg_values_supported parameter inside the openid_provider type is checked. The must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"not\": {\"contains\": {\"enum\": [\"none\",\"HS256\",\"HS384\",\"HS512\"]}}},\"subset_of\": {\"not\": {\"contains\": {\"enum\": [\"none\",\"HS256\",\"HS384\",\"HS512\"]}}}},\"required\": [\"superset_of\",\"subset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_encryption_alg_values_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encryption_alg_values_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encryption_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_encryption_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encryption_alg_values_supported parameter inside the openid_provider type is checked. It must contain superset_of=[\"RSA-OAEP\", \"RSA-OAEP-256\"], subset_of=[\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encryption_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RSA-OAEP\",\"RSA-OAEP-256\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RSA-OAEP\",\"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain not valid values for the userinfo_encryption_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encryption_alg_values_supported parameter inside the openid_provider type is checked. Must not contain the value ['RSA_1_5']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encryption_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"not\": {\"contains\": {\"enum\": [\"RSA_1_5\"]}}},\"subset_of\": {\"not\": {\"contains\": {\"enum\": [\"RSA_1_5\"]}}}},\"required\": [\"superset_of\",\"subset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_encryption_enc_values_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encryption_enc_values_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encryption_enc_values_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_encryption_enc_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encryption_enc_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' valued with ['A128CBC-HS256', 'A256CBC-HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encryption_enc_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"A128CBC-HS256\",\"A128CBC-HS512\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"A128CBC-HS256\",\"A128CBC-HS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the token_endpoint_auth_methods_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the token_endpoint_auth_methods_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.token_endpoint_auth_methods_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the token_endpoint_auth_methods_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the token_endpoint_auth_methods_supported parameter inside the openid_provider type is checked. It must contain subset_of=[\"private_key_jwt\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.token_endpoint_auth_methods_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"private_key_jwt\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct token_endpoint_auth_signing_alg_values_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_signing_alg_values_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.token_endpoint_auth_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct token_endpoint_auth_signing_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain superset_of=[\"RS256\", \"RS512\"], subset_of=[\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.token_endpoint_auth_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\",\"RS512\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\",\"RS512\", \"ES256\", \"ES512\", \"PS256\",\"PS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain not valid values for the token_endpoint_auth_signing_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_signing_alg_values_supported parameter inside the openid_provider type is checked. The key 'subset_of' must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.token_endpoint_auth_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"not\": {\"contains\": {\"enum\": [\"none\",\"HS256\",\"HS384\",\"HS512\"]}}},\"subset_of\": {\"not\": {\"contains\": {\"enum\": [\"none\",\"HS256\",\"HS384\",\"HS512\"]}}}},\"required\": [\"superset_of\",\"subset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct claims_parameter_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the claims_parameter_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.claims_parameter_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct claims_parameter_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the claims_parameter_supported parameter inside the openid_provider type is checked. It must contain value=true AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.claims_parameter_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"value\": {\"type\": \"boolean\",\"const\": true},  \"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"value\",  \"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_parameter_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_parameter_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_parameter_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_parameter_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_parameter_supported parameter inside the openid_provider type is checked. It must contain value=true AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_parameter_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"value\": {\"type\": \"boolean\",\"const\": true},  \"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"value\",  \"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct authorization_response_iss_parameter_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the authorization_response_iss_parameter_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.authorization_response_iss_parameter_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct authorization_response_iss_parameter_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the authorization_response_iss_parameter_supported parameter inside the openid_provider type is checked. It must contain value=true AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.authorization_response_iss_parameter_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"value\": {\"type\": \"boolean\",\"const\": true},  \"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"value\",  \"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct client_registration_types_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the client_registration_types_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.client_registration_types_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct client_registration_types_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the client_registration_types_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' and it must be valued as ['automatic']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.client_registration_types_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"subset_of\": {\"type\": \"array\",\"const\": [\"automatic\"]},  \"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"subset_of\",  \"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_authentication_methods_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_authentication_methods_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_authentication_methods_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_authentication_methods_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_authentication_methods_supported parameter inside the openid_provider type is checked. It must contain value=true AND {\"essential\":true}.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_authentication_methods_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"value\": {\"type\": \"boolean\",\"const\": true},  \"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"value\",  \"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_authentication_signing_alg_values_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the request_authentication_signing_alg_values_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.request_authentication_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_authentication_signing_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the request_authentication_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain superset_of=[\"RS256\", \"RS512\"], subset_of=[\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.request_authentication_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\",\"RS512\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\",\"RS512\", \"ES256\", \"ES512\", \"PS256\",\"PS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain not valid values for the request_authentication_signing_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the request_authentication_signing_alg_values_supported parameter inside the openid_provider type is checked. Must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.request_authentication_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"not\": {\"contains\": {\"enum\": [\"none\",\"HS256\",\"HS384\",\"HS512\"]}}},\"subset_of\": {\"not\": {\"contains\": {\"enum\": [\"none\",\"HS256\",\"HS384\",\"HS512\"]}}}},\"required\": [\"superset_of\",\"subset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_object_signing_alg_values_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_object_signing_alg_values_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.request_object_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_object_signing_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_object_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain superset_of=[\"RS256\", \"RS512\"], subset_of=[\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.request_object_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\",\"RS512\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\",\"RS512\", \"ES256\", \"ES512\", \"PS256\",\"PS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_object_signing_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_object_signing_alg_values_supported parameter inside the openid_provider type is checked. It must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.request_object_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"not\": {\"contains\": {\"enum\": [\"none\",\"HS256\",\"HS384\",\"HS512\"]}}},\"subset_of\": {\"not\": {\"contains\": {\"enum\": [\"none\",\"HS256\",\"HS384\",\"HS512\"]}}}},\"required\": [\"superset_of\",\"subset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct issuer parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the issuer parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.issuer",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct issuer parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the issuer parameter inside the openid_provider type is checked. It must contain {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.issuer",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct authorization_endpoint parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the authorization_endpoint parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.authorization_endpoint",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct authorization_endpoint parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the authorization_endpoint parameter inside the openid_provider type is checked. It must contain  {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.authorization_endpoint",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct token_endpoint parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the token_endpoint parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.token_endpoint",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct token_endpoint parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the token_endpoint parameter inside the openid_provider type is checked. It must contain  {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.token_endpoint",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_endpoint parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the userinfo_endpoint parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_endpoint",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_endpoint parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the userinfo_endpoint parameter inside the openid_provider type is checked. It must contain  {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_endpoint",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct introspection_endpoint parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the introspection_endpoint parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.introspection_endpoint",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct introspection_endpoint parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the introspection_endpoint parameter inside the openid_provider type is checked. It must contain  {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.introspection_endpoint",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct revocation_endpoint parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the revocation_endpoint parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.revocation_endpoint",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct revocation_endpoint parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the revocation_endpoint parameter inside the openid_provider type is checked. It must contain  {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.revocation_endpoint",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    }
  ]
}