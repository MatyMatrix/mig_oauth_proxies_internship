{
  "test suite": {
    "name": "Passive",
    "description": "All the passive",
    "filter messages": true
  },
  "tests": [
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the policy_uri claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "policy_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the tos_uri claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "tos_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the claims claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the claims claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "claims",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the service_documentation claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "service_documentation",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration of a considered entity return a Federation Metadata in JOSE format when an HTTP GET request is made to its .well-known/openid-federation endpoint",
        "description": "The considered entity must have published its entity configuration in the .well-known/openid-federation endpoint. So in this test, an HTTP GET request is made to the entity's .well-known/openid-federation endpoint (appended to the URL which identifies the entity) and the response is analyzed. This response has to be the entity configuration of the entity and therefore a Federation Metadata in JOSE format (Content-Type: application/entity-statement+jwt)",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the resolve entity statement endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request containing the parameters 'sub', 'anchor' and 'type' is made to the entity's endpoint and an HTTP 200 OK response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Resolve Entity Statement response",
            "checks": [
              {
                "in": "body",
                "check regex": "[\\s*\"[^\"]*\"(?:,\\s*\"[^\"]*\")*\\s*\\]$",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain incorrect token_endpoint_auth_signing_alg_values_supported claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the token_endpoint_auth_signing_alg_values_supported claim in the 'oauth_authorization_server' entity type is checked. It must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.token_endpoint_auth_signing_alg_values_supported",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain incorrect dpop_signing_alg_values_supported claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the dpop_signing_alg_values_supported claim in the 'oauth_authorization_server' entity type is checked. It must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.dpop_signing_alg_values_supported.one_of",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the organization_name claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the organization_name claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.organization_name",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the homepage_uri claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the homepage_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.homepage_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the policy_uri claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the policy_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.policy_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the logo_uri claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the logo_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.logo_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the contacts claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the contacts claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.contacts",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the federation_resolve_endpoint claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the federation_resolve_endpoint claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_resolve_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the federation_trust_mark_status_endpoint claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the federation_trust_mark_status_endpoint claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_trust_mark_status_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the issuer claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the issuer claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.issuer",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the authorization_endpoint claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the authorization_endpoint claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.authorization_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the token_endpoint claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the token_endpoint claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.token_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the jwks claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the jwks claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the scopes_supported claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the scopes_supported claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.scopes_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the response_types_supported claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the response_types_supported claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.response_types_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the grant_types_supported claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the grant_types_supported claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.grant_types_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the token_endpoint_auth_methods_supported claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the token_endpoint_auth_methods_supported claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.token_endpoint_auth_methods_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the token_endpoint_auth_signing_alg_values_supported claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the token_endpoint_auth_signing_alg_values_supported claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.token_endpoint_auth_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the op_policy_uri claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the op_policy_uri claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.op_policy_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the op_tos_uri claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the op_tos_uri claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.op_tos_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain dpop_signing_alg_values_supported claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the dpop_signing_alg_values_supported claim in the 'oauth_authorization_server' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.dpop_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the resource claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the resource claim in the 'oauth_resource' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_resource.resource",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the iss parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the sub parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the iat parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the exp parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the jwks parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the metadata parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the metadata parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's entity configuration contain the authority_hints parameter",
        "description": "To accomplish this test, the Entity configuration of the OP is taken, the payload is decoded (Base64 encoding) and the presence of the authority_hints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.authority_hints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain the trust_marks parameter",
        "description": "To accomplish this test, the Entity configuration is taken, the payload is decoded (Base64 encoding) and the presence of the trust_marks parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Configuration",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Configuration Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_AA"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain a correctly signed trust_marks",
        "description": "To accomplish this test, the Entity configuration is taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_AA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the /.well-known/openid-federation endpoint",
        "description": "In order to check the presence and correctness of the /.well-known/openid-federation endpoint, an HTTP GET request to the entity's endpoint is done and its entity configuration is expected as response.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the EC response",
        "description": "In this test a correct request to the entity's /.well-known/openid-federation endpoint is made and the response is analyzed. It must be an HTTP 200 OK response",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the resolve entity statement endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request containing the parameters 'sub', 'anchor' and 'type' is made to the entity's endpoint and an HTTP 200 OK response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Resolve Entity Statement response",
            "checks": [
              {
                "in": "body",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the policy_uri claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"policy_uri\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"policy_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the policy_uri claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"policy_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"policy_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the tos_uri claim is checked to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"tos_uri\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"tos_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the tos_uri claim is checked to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"tos_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"tos_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct claims claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the value of the claims claim is checked to be a list",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"claims\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"claims\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) is taken and the service_documentation claim is checked to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"service_documentation\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"service_documentation\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) is taken and the service_documentation claim is checked to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"service_documentation\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"service_documentation\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct Content-Type in the EC response",
        "description": "In this test a correct request to the entity's /.well-known/openid-federation endpoint is made and the response is analyzed. It must have a Content-Type parameter set to application/entity-statement+jwt",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "checks": [
              {
                "in": "head",
                "url decode": false,
                "is": "application/entity-statement+jwt",
                "check param": "Content-Type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'openid_relying_party'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "openid_relying_party.*(\\n.*)+\"openid_relying_party\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'openid_provider'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "openid_provider.*(\\n.*)+\"openid_provider\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'federation_entity'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "federation_entity.*(\\n.*)+\"federation_entity\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'oauth_authorization_server'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "oauth_authorization_server.*(\\n.*)+\"oauth_authorization_server\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one  'oauth_resource'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "oauth_resource.*(\\n.*)+\"oauth_resource\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct iss parameter value",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked. It must identify the issuing entity.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is": "X_url_AA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration OP contain a correct sub parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the sub parameter is checked. Its value must be equal to the one in the iss parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is": "X_url_AA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the token_endpoint_auth_methods_supported claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the token_endpoint_auth_methods_supported claim in the 'oauth_authorization_server' entity type is checked. It must contain the key-value pair ['private_key_jwt']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.token_endpoint_auth_methods_supported",
                    "is in": [
                      "private_key_jwt"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain correct token_endpoint_auth_signing_alg_values_supported claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the token_endpoint_auth_signing_alg_values_supported claim in the 'oauth_authorization_server' entity type is checked to be ['RS256', 'RS512'].",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.token_endpoint_auth_signing_alg_values_supported",
                    "is in": [
                      "RS256",
                      "RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain correct dpop_signing_alg_values_supported claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the dpop_signing_alg_values_supported claim in the 'oauth_authorization_server' entity type is 'one_of': ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server.dpop_signing_alg_values_supported.one_of",
                    "is in": [
                      "RS256",
                      "RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct iss parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct iss parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct sub parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the sub parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct sub parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the sub parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain a correct iat parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain a correct exp parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct jwks parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the jwks parameter is checked. It must be JSON Object that contains keys, which is a JSON Array, which contains at least kty, which is a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct jwks parameter type for IT",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the jwks parameter is checked. It must contain at least KID.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}, \"kid\":{\"type\":\"string\"}},\"required\":[\"kty\", \"kid\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain a JSON Object",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"metadata\": {\"type\": \"object\"}}, \"required\": [\"metadata\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only allowed types",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "json schema compliant": "{\"type\": \"object\",\"anyOf\": [{\"required\": [\"openid_relying_party\"]},{\"required\": [\"openid_provider\"]},{\"required\": [\"federation_entity\"]},{\"required\": [\"oauth_authorization_server\"]},{\"required\": [\"oauth_resource\"]}],\"properties\": {\"openid_relying_party\":{\"type\":\"object\"},\"openid_provider\":{\"type\":\"object\"},\"federation_entity\":{\"type\":\"object\"},\"oauth_authorization_server\":{\"type\":\"object\"},\"oauth_resource\":{\"type\":\"object\"}}, \"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's entity configuration contain a correct authority_hints parameter",
        "description": "To accomplish this test, the Entity configuration of the OP is taken, the payload is decoded (Base64 encoding) and the authority_hints parameter is checked, it must be an array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"authority_hints\": {\"type\": \"array\", \"items\":{\"type\":\"string\"}}}, \"required\": [\"authority_hints\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's entity configuration contain a correct authority_hints parameter",
        "description": "To accomplish this test, the Entity configuration of the OP is taken, the payload is decoded (Base64 encoding) and the authority_hints parameter is checked, it must be an array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"authority_hints\": {\"type\": \"array\", \"items\":{\"type\":\"uri\"}}}, \"required\": [\"authority_hints\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain a correct trust_marks parameter",
        "description": "To accomplish this test, the Entity configuration is taken, the payload is decoded (Base64 encoding) and the type of the trust_marks parameter is checked. It must be an array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"trust_marks\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"array\"}}}, \"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain a correct trust_marks parameter value",
        "description": "To accomplish this test, the Entity configuration is taken, the payload is decoded (Base64 encoding) and the type of the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct organization_name claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the organization_name claim in the 'federation_entity' entity type is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"organization_name\": {\"type\": \"string\"}},\"required\": [\"organization_name\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct homepage_uri claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the homepage_uri claim in the 'federation_entity' entity type is checked. It must be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"homepage_uri\": {\"type\": \"string\",\"format\": \"uri\"}},\"required\": [\"homepage_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct policy_uri claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the policy_uri claim in the 'federation_entity' entity type is checked. It must be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"policy_uri\": {\"type\": \"string\",\"format\": \"uri\"}},\"required\": [\"policy_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain correct type logo_uri claim",
        "description": "In this test the metadata in the TA Entity Configuration are taken and the value of the logo_uri claim in the 'federation_entity' entity type is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"logo_uri\":{\"type\":\"string\"}},\"required\":[\"logo_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain a correct logo_uri claim",
        "description": "In this test the metadata in the TA Entity Configuration are taken and the value of the logo_uri claim in the 'federation_entity' entity type is an HTTPS URL with an .svg file",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"logo_uri\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://.*\\\\.svg$\"}},\"required\":[\"logo_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain correct type contacts claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the value of the contacts claim in the 'federation_entity' entity type is a JSON Array of String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"contacts\":{\"type\":\"array\", \"items\":{\"type\":\"string\"}}},\"required\":[\"contacts\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct federation_resolve_endpoint claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the federation_resolve_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_resolve_endpoint\": {\"type\": \"string\",\"format\": \"uri\", \"pattern\": \"^https://[^#]+$\"}},\"required\": [\"federation_resolve_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct federation_resolve_endpoint claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the federation_resolve_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL that ends with /trust_mark_status.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_resolve_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://.*/resolve\"}},\"required\": [\"federation_resolve_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain at least federation_entity and oauth_resource",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the federation_entity and oauth_resource is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_entity\": {\"type\": \"object\"},\"oauth_resource\": {\"type\": \"object\"}},\"required\": [\"federation_entity\",\"oauth_resource\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the correct federation_trust_mark_status_endpoint claim type",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the federation_trust_mark_status_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_trust_mark_status_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\"}},\"required\": [\"federation_trust_mark_status_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the correct federation_trust_mark_status_endpoint claim type",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the federation_trust_mark_status_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL that ends with /trust_mark_status.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_trust_mark_status_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://.*/trust_mark_status\"}},\"required\": [\"federation_trust_mark_status_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain a correct type of issuer claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the issuer claim in the 'oauth_authorization_server' entity type is a URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"issuer\":{\"type\":\"string\", \"format\":\"uri\"}},\"required\":[\"issuer\"]})"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain a correct type of issuer claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the issuer claim in the 'oauth_authorization_server' entity type is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"issuer\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://\"}},\"required\":[\"issuer\"]})"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain a correct type of issuer claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the issuer claim in the 'oauth_authorization_server' entity type is a URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"issuer\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://x_url_AA\"}},\"required\":[\"issuer\"]})"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain correct type authorization_endpoint claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the authorization_endpoint claim in the 'oauth_authorization_server' entity type is \"private\"",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"authorization_endpoint\": {\"type\": \"string\",\"format\": \"uri\", \"pattern\": \"^https://\"}},\"required\": [\"authorization_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain correct type token_endpoint claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the token_endpoint claim in the 'oauth_authorization_server' entity type is an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"token_endpoint\": {\"type\": \"string\",\"format\": \"uri\"}},\"required\": [\"token_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain correct type token_endpoint claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the token_endpoint claim in the 'oauth_authorization_server' entity type is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"token_endpoint\": {\"type\": \"string\",\"format\": \"uri\", \"pattern\": \"^https://\"}},\"required\": [\"token_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the correct jwks claim type",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the jwks claim in the 'oauth_authorization_server' entity type is checked. It must be a JSON Object that contains keys, which is a JSON Array, which contains at least kty, which is a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata.oauth_authorization_server.jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the correct jwks claim type",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the jwks claim in the 'oauth_authorization_server' entity type is checked. It must be a JSON Object that contains keys, which is a JSON Array, which contains kid, which is a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata.oauth_authorization_server.jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kid\":{\"type\":\"string\"}},\"required\":[\"kid\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the correct scopes_supported claim type",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the scopes_supported claim in the 'oauth_authorization_server' entity type is checked. It must be a JSON Array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata.oauth_authorization_server",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"scopes_supported\":{\"type\":\"array\"}},\"required\":[\"scopes_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the correct response_types_supported claim type",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the response_types_supported claim in the 'oauth_authorization_server' entity type is checked. It must be a JSON Array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata.oauth_authorization_server",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"response_types_supported\":{\"type\":\"array\"}},\"required\":[\"response_types_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the correct grant_types_supported claim type",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the grant_types_supported claim in the 'oauth_authorization_server' entity type is checked. It must be a JSON Array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata.oauth_authorization_server",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"grant_types_supported\":{\"type\":\"array\"}},\"required\":[\"grant_types_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the correct token_endpoint_auth_methods_supported claim type",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the token_endpoint_auth_methods_supported claim in the 'oauth_authorization_server' entity type is checked. It must be a JSON Array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata.oauth_authorization_server",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"token_endpoint_auth_methods_supported\":{\"type\":\"array\"}},\"required\":[\"token_endpoint_auth_methods_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain the correct token_endpoint_auth_signing_alg_values_supported claim type",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the presence of the token_endpoint_auth_signing_alg_values_supported claim in the 'oauth_authorization_server' entity type is checked. It must be a JSON Array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata.oauth_authorization_server",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"token_endpoint_auth_signing_alg_values_supported \":{\"type\":\"array\"}},\"required\":[\"token_endpoint_auth_signing_alg_values_supported \"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain correct type op_policy_uri claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the op_policy_uri claim in the 'oauth_authorization_server' entity type is an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"op_policy_uri\": {\"type\": \"string\",\"format\": \"uri\"}},\"required\": [\"op_policy_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain correct type op_policy_uri claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the op_policy_uri claim in the 'oauth_authorization_server' entity type is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"op_policy_uri\": {\"type\": \"string\",\"format\": \"uri\", \"pattern\":\"^https://\"}},\"required\": [\"op_policy_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain correct type op_tos_uri claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the op_tos_uri claim in the 'oauth_authorization_server' entity type is an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"op_tos_uri\": {\"type\": \"string\",\"format\": \"uri\"}},\"required\": [\"op_tos_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain correct type op_tos_uri claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the op_policy_uri claim in the 'oauth_authorization_server' entity type is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"op_tos_uri\": {\"type\": \"string\",\"format\": \"uri\", \"pattern\":\"^https://\"}},\"required\": [\"op_tos_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain correct type dpop_signing_alg_values_supported claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the dpop_signing_alg_values_supported claim in the 'oauth_authorization_server' entity type is an JSON Array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_authorization_server",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"dpop_signing_alg_values_supported\": {\"type\": \"array\"}},\"required\": [\"dpop_signing_alg_values_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the AA metadata contain correct type resource claim",
        "description": "In this test the AA metadata in the AA Entity Configuration are taken and the value of the resource claim in the 'oauth_resource' entity type is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.oauth_resource",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"resource\": {\"oneOf\": [{\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"},{\"type\": \"array\",\"items\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"},\"minItems\": 1}]}},\"required\": [\"resource\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the entity listing endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request to the entity's endpoint is done. A response containing a JSON list with the known Entity Identifiers is expected",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Listing response",
            "checks": [
              {
                "in": "body",
                "check regex": "\\[\\s*\"[^\"]*\"(?:,\\s*\"[^\"]*\")*\\s*\\]$",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA_SA's metadata contain the federation_fetch_endpoint parameter",
        "description": "In this test the TA_SA metadata are taken and the presence of the 'federation_fetch_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA_SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_fetch_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA_SA's metadata contain the federation_list_endpoint parameter",
        "description": "In this test the TA_SA metadata are taken and the presence of the 'federation_list_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA_SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_list_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA_SA's metadata contain the federation_trust_mark_status_endpoint parameter",
        "description": "In this test the TA_SA metadata are taken and the presence of the 'federation_trust_mark_status_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA_SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_trust_mark_status_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the entity listing endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request to the entity's endpoint is done. A response containing a JSON list with the known Entity Identifiers is expected",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Listing response",
            "checks": [
              {
                "in": "url",
                "is present": true,
                "check": "HTTP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA_SA metadata contain at least federation_entity",
        "description": "In this test the TA_SA metadata in the TA_SA Entity Configuration are taken and the presence of the federation_entity is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA_SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_entity\": {\"type\": \"object\"}},\"required\": [\"federation_entity\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA_SA metadata contain the correct federation_fetch_endpoint claim type",
        "description": "In this test the TA_SA metadata in the TA_SA Entity Configuration are taken and the presence of the federation_fetch_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA_SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_fetch_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://\"}},\"required\": [\"federation_fetch_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA_SA metadata contain the correct federation_fetch_endpoint claim type",
        "description": "In this test the TA_SA metadata in the TA_SA Entity Configuration are taken and the presence of the federation_fetch_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL that ends with /trust_mark_status.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA_SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_fetch_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://.*/fetch\"}},\"required\": [\"federation_fetch_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA_SA metadata contain the correct federation_list_endpoint claim type",
        "description": "In this test the TA_SA metadata in the TA_SA Entity Configuration are taken and the presence of the federation_list_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA_SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_trust_mark_status_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://\"}},\"required\": [\"federation_trust_mark_status_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA_SA metadata contain the correct federation_list_endpoint claim type",
        "description": "In this test the TA_SA metadata in the TA_SA Entity Configuration are taken and the presence of the federation_list_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL that ends with /list.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA_SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_trust_mark_status_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://.*/list\"}},\"required\": [\"federation_trust_mark_status_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA_SA metadata contain the correct federation_trust_mark_status_endpoint claim type",
        "description": "In this test the TA_SA metadata in the TA_SA Entity Configuration are taken and the presence of the federation_trust_mark_status_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA_SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_trust_mark_status_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\"}},\"required\": [\"federation_trust_mark_status_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA_SA metadata contain the correct federation_trust_mark_status_endpoint claim type",
        "description": "In this test the TA_SA metadata in the TA_SA Entity Configuration are taken and the presence of the federation_trust_mark_status_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL that ends with /trust_mark_status.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA_SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_trust_mark_status_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://.*/trust_mark_status\"}},\"required\": [\"federation_trust_mark_status_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the logo_uri claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the logo_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA_SA_OP_AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.logo_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration of a considered entity return a Federation Metadata in JOSE format when an HTTP GET request is made to its .well-known/openid-federation endpoint",
        "description": "The considered entity must have published its entity configuration in the .well-known/openid-federation endpoint. So in this test, an HTTP GET request is made to the entity's .well-known/openid-federation endpoint (appended to the URL which identifies the entity) and the response is analyzed. This response has to be the entity configuration of the entity and therefore a Federation Metadata in JOSE format (Content-Type: application/entity-statement+jwt)",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the resolve entity statement endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request containing the parameters 'sub', 'anchor' and 'type' is made to the entity's endpoint and an HTTP 200 OK response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Resolve Entity Statement response",
            "checks": [
              {
                "in": "body",
                "check regex": "[\\s*\"[^\"]*\"(?:,\\s*\"[^\"]*\")*\\s*\\]$",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP contain the correct type of code parameter on redirect in a successful authentication",
        "description": "In order to check if the OP correctly handles a successful authentication request, a correct request is sent by a client and the behavior of the OP is analyzed. In particular, the client must be redirected to its redirect_uri and the redirect must have 'code' as query parameter and it must be a UUID.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication response",
            "checks": [
              {
                "in": "head",
                "check regex": "(?<=code=)[a-zA-Z0-9]+(?=&)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'state' parameter greater than 32 characters",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the value of the 'state' parameter must be at least 32 alphanumeric characters long. If it is not present or its length is less than 32 alphanumeric characters, then the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication response",
            "checks": [
              {
                "in": "head",
                "check regex": "(?<=state=)(?<=state=)[\\x20-\\x7E]{32,}?(?=&)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP contain iss set to the its identifier on redirect in a successful authentication",
        "description": "In order to check if the OP correctly handles a successful authentication request, a correct request is sent by a client and the behavior of the OP is analyzed. In particular, the client must be redirected to its redirect_uri and the redirect must have 'iss' as query parameter set to the OP's identifier",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "checks": [
              {
                "in": "url",
                "check regex": "(?<=client_id=)https:\\/\\/.*?(?=&)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the successful token response contain a valid access token",
        "description": "In this test a correct Token request is sent and the response is analyzed. It must contain the access token parameter and its value must be a JWT",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "body",
                "check regex": "(?<=\"access_token\":\\s?)\"([\\w\\-]+\\.[\\w\\-]+\\.[\\w\\-]+)\"",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP issue the expires_in in a token response",
        "description": "In this test an RP makes a correct authentication request and, once received the code, the RP tries to exchange it in the token endpoint. The response is then analyzed and it must contain the expires_in parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "body",
                "check regex": "(?<=\"expires_in\": )[\\d]+?(?=,)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the successful token response contain a valid ID token",
        "description": "The RP receiving the Token response and that sent a correct token request must check the presence of a valid ID token",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "body",
                "check regex": "(?<=\"id_token\":\\s?)\"([\\w\\-]+\\.[\\w\\-]+\\.[\\w\\-]+)\"",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the UserInfo Endpoint create a signed and encrypted JWT",
        "description": "The UserInfo response is taken and the presence of a signed and encrypted JWE in the body of the response is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "checks": [
              {
                "in": "body",
                "check regex": "[\\w\\-]+\\.[\\w\\-]+\\.[\\w\\-]+\\.[\\w\\-]+\\.[\\w\\-]+$",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Endpoint Response have the correct type exp parameter",
        "description": "To test that the Introspection response of the OP's correctly answers to valid tokens, a valid one is sent and the response is analyzed. It must be a date-time format",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection response",
            "checks": [
              {
                "in": "body",
                "check regex": "\"exp\":\\s*\"\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z\"",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Endpoint Response have the correct value sub parameter",
        "description": "To test that the Introspection response of the OP's correctly answers to valid tokens, a valid one is sent and the response is analyzed. It must be Uniquely Identifier of the OP",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection response",
            "checks": [
              {
                "in": "body",
                "check regex": "\"sub\": \"X_url_RP\"",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Endpoint Response have the correct type client_id parameter",
        "description": "To test that the Introspection response of the OP's correctly answers to valid tokens, a valid one is sent and the response is analyzed. It must be a URI format",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection response",
            "checks": [
              {
                "in": "body",
                "check regex": "\"client_id\":\\s*\"(https?://[^\\s]+)\"",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Endpoint Response have the correct value client_id parameter",
        "description": "To test that the Introspection response of the OP's correctly answers to valid tokens, a valid one is sent and the response is analyzed. It must be Uniquely Identifier of the OP",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection response",
            "checks": [
              {
                "in": "body",
                "check regex": "\"client_id\": \"X_url_RP\"",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Endpoint Response have the correct type iss parameter",
        "description": "To test that the Introspection response of the OP's correctly answers to valid tokens, a valid one is sent and the response is analyzed. It must be a URI format",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection response",
            "checks": [
              {
                "in": "body",
                "check regex": "\"iss\":\\s*\"(https?://[^\\s]+)\"",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Endpoint Response have the correct value iss parameter",
        "description": "To test that the Introspection response of the OP's correctly answers to valid tokens, a valid one is sent and the response is analyzed. It must be Uniquely Identifier of the OP",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection response",
            "checks": [
              {
                "in": "body",
                "check regex": "\"iss\": \"X_url_OP\"",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Endpoint Response have the correct type aud parameter",
        "description": "To test that the Introspection response of the OP's correctly answers to valid tokens, a valid one is sent and the response is analyzed. It must be a URI format",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection response",
            "checks": [
              {
                "in": "body",
                "check regex": "\"aud\":\\s*\\[\\s*\".*?\"\\s*(,\\s*\".*?\")*\\s*\\]",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Endpoint Response have the correct value aud parameter",
        "description": "To test that the Introspection response of the OP's correctly answers to valid tokens, a valid one is sent and the response is analyzed. It must be Uniquely Identifier of the OP",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection response",
            "checks": [
              {
                "in": "body",
                "check regex": "\"aud\":\\s*\\[\\s*\"(https?://[^\\s\"]+)\"(?:\\s*,\\s*\"(https?://[^\\s\"]+)\")*\\s*\\]",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain a wrong 'alg' parameter in the Header",
        "description": "In this test, the Access Token is taken from the Token Response, the header is base64url decoded and the presence of the 'alg' parameter in the Header is checked. If its value is set to none, contains values among ['none', 'HS256', 'HS384', 'HS512'], is absent or contains a symmetric algorithm, than the Access Token is not compliant.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.alg",
                    "is not in": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain a wrong 'alg' parameter in the Header",
        "description": "In this test, the ID Token is taken from the Token Response, the header is base64url decoded and the presence of the 'alg' parameter in the Header is checked. If its value is set to none, contains values among ['none', 'HS256', 'HS384', 'HS512'], is absent or contains a symmetric algorithm, than the ID Token is not compliant.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.alg",
                    "is not in": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the UserInfo Response's JWE contain a correct alg parameter in the JOSE Header",
        "description": "In this test, the JWE is taken from the Userinfo Response's body, the header is base64url decoded and the presence of the 'alg' parameter in the Header is checked. If its value is set to none, contains values among ['none', 'HS256', 'HS384', 'HS512'], is absent or contains a symmetric algorithm, than the Token is not compliant.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "decode operations": [
              {
                "jwe decrypt": "-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC5d8kD7BOVMIDg\nV2ygTSpl+YoiB52Zquu1aBBsSUptaD1ENHtnwlUFpEsWrDJ/IbUkkWbrgbnVwEnA\nsgXBagXufGwf1VgubmhyMCexHhGGV9UTTL/rTCN/yyQmAFGmJdA+XAf2MMZqpUT8\n8QFM5sM7nDdei6sPUXfrT6/lwsMtEd0UkiK10RW2oBOpjkOCVENoqIGGKztrn/Vu\nTzf08MtpCGO7hcmTi28PLn4tWQzLmw/bNTr7W0l0D5WZoFktfL2fT3rsUYhaYzOl\np+sEw64cVxQ4fnqj5yUNqH8IhMfV2rYPrgrQxiESkAI7anwAfgrxDpi4nV2eRUMP\nBmnYLzixAgMBAAECggEBAJ/3jyuQ3TsagK3++bQxmlYmK1w6kVZPM8pdnXyookdH\nV0CSu7W8ybR6BkHh+BPrMN//gXOzimOw3GwVoB04ozEVo/S5ALvbgr6qhjGgK6Fh\n9GgXFJmQLDY3MlCMid/yUXDX1A4l951YOu6nuGVpzA6IKMGlWb92lyYgryhPGiSu\nAVf5xdzbeUes1GKY2UPE9Rg2Qld782t6oJQ613vM6HPqfHC7N6yZ+7TFUiVc5wiK\njn3jNVSINCN59m7m2DsfPLHJB7g53104kw5cquSMA8gR5oiHt36bvnOHtbYgZmzn\n9iKgwml/EnaZ1NoE4/WJWbUTapodzQf65LASli897iECgYEA5PA7lJEDd3vrw5hl\nolFzvjvRriOu1SMHXx9Y52AgpOeQ6MnE1pO8qwn33lwYTSPGYinaq4jS3FKF/U5v\nOZltJAGBMa4ByEvAROJVCh958rKVRWKIqVXLOi8Gk11kHbVKw6oDXAd8Qt/y/ff8\nk/K6jW2EbWm1K6kfTvTMzoHkqrUCgYEAz2QeMH4WtrdiWUET7JgZNX0TbcaVBgd2\nGpo8JHnfnGOUsvO/euKGgqpCcxiWVXSlqffQyTgVzl4iMROP8bEaQwvueHurtziM\nDSy9Suumyktu3PbGgjqu/izRim8Xlg7sz8Hs2quJPII/fQ8BCoaWpg30osFZqCBa\nrQM7CWhxR40CgYA3CVWZap8lu0G7XMiaE/C6O9E1htiB3pDoGjYaMW7Hle+tNsw+\nNXf2uke/Se6BpOcNNDigYh0m4CPb+F4ev7aQIFh5o/ZDu4o2RR7idxyu7qWZ740h\nAEIB88ol5R6rUajujtGN7zK9NO9KhLJQstqMI1bhorbuDxM6vPj7cBiTvQKBgQDJ\nfuJ+BuOWntHlGf97rcNAXsdTrs73TqSG8Ddi0S5ayb2dqIjvoctChJ2PKeJWIMEc\nRHQMLHuzR2489F60WnfDkIIfeTi7CSu5WTCI7C/e+C88bF8uBEolFfJ4Z7soxlN6\n/1Val7L8oSeCH+PJED6qE4EN6IFtghHXav4fA+SbuQKBgQCNy7q3MoBOxDlKOpSN\nChoYUfW0JvwJbyyaVYOVq0efGVobosAblE/IuwaoIuVgh8c4T3qZtwFcSpvfR5Qy\nSOWFs2QXN/P4ZvmiVpXK/9Tcnth2BThpb9apQCT2a/CYtrRiGNAVWKiK0U9QlN/w\n9fVBO/ZgdaXE4xqYOSceH14yrQ==\n-----END PRIVATE KEY-----\n",
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.alg",
                    "is not in": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain incorrect id_token_signing_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'id_token_signing_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked. It must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.id_token_signing_alg_values_supported",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain an incorrect id_token_encryption_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'id_token_encryption_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked. It must not contain the value ['RSA_1_5']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.id_token_encryption_alg_values_supported",
                    "not contains": [
                      "RSA_1_5"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain incorrect userinfo_signing_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'userinfo_signing_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked. It must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.userinfo_signing_alg_values_supported",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain incorrect userinfo_encryption_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'userinfo_encryption_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked. It must not contain the values ['RSA_1_5']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.userinfo_encryption_alg_values_supported",
                    "not contains": [
                      "RSA_1_5"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain incorrect request_object_signing_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'request_object_signing_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked. It must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.request_object_signing_alg_values_supported",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain incorrect token_endpoint_auth_signing_alg_values_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the value of the token_endpoint_auth_signing_alg_values_supported claim in the 'openid_provider' entity type is checked. It must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.token_endpoint_auth_signing_alg_values_supported",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain incorrect request_authentication_signing_alg_values_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the value of the request_authentication_signing_alg_values_supported claim in the 'openid_provider' entity type is checked. It must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.request_authentication_signing_alg_values_supported[0]",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the organization_name claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the organization_name claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.organization_name",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the homepage_uri claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the homepage_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.homepage_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the policy_uri claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the policy_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.policy_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the logo_uri claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the logo_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.logo_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the contacts claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the contacts claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.contacts",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the federation_resolve_endpoint claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the federation_resolve_endpoint claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_resolve_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the issuer parameter",
        "description": "In this test the OP metadata are taken and the presence of the 'issuer' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.issuer",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the authorization_endpoint parameter",
        "description": "In this test the OP metadata are taken and the presence of the 'authorization_endpoint' parameter in the 'openid_provider' subclaim (metadata type) is checked. It must be present",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.authorization_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the token_endpoint parameter",
        "description": "In this test the OP metadata are taken and the presence of the 'token_endpoint' parameter in the 'openid_provider' subclaim (metadata type) is checked. It must be present",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.token_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the userinfo_endpoint parameter",
        "description": "In this test the OP metadata are taken and the presence of the 'userinfo_endpoint' parameter in the 'openid_provider' subclaim (metadata type) is checked. It must be present",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.userinfo_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the introspection_endpoint parameter",
        "description": "In this test the OP metadata are taken and the presence of the 'introspection_endpoint' parameter in the 'openid_provider' subclaim (metadata type) is checked. It must be present",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.introspection_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the revocation_endpoint parameter",
        "description": "In this test the OP metadata are taken and the presence of the 'revocation_endpoint' parameter in the 'openid_provider' subclaim (metadata type) is checked. It must be present",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.revocation_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the revocation_endpoint_auth_methods_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'revocation_endpoint_auth_methods_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.revocation_endpoint_auth_methods_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the code_challenge_methods_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'code_challenge_methods_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.code_challenge_methods_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the scopes_supported claim",
        "description": "In this test the OP metadata are taken and the presence of the 'scopes_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.scopes_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the response_types_supported claim",
        "description": "In this test the OP metadata are taken and the presence of the 'response_types_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.response_types_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the response_modes_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'response_modes_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.response_modes_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the grant_types_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'grant_types_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.grant_types_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the acr_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'acr_values_supported' in the 'openid_provider' subclaim (metadata type) parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.acr_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the subject_types_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'subject_types_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.subject_types_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the id_token_signing_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'id_token_signing_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.id_token_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the id_token_encryption_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'id_token_encryption_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.id_token_encryption_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the id_token_encryption_enc_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'id_token_encryption_enc_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.id_token_encryption_enc_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the userinfo_signing_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'userinfo_signing_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.userinfo_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the userinfo_encryption_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'userinfo_encryption_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.userinfo_encryption_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the userinfo_encryption_enc_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'userinfo_encryption_enc_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.userinfo_encryption_enc_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the request_object_signing_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'request_object_signing_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.request_object_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the token_endpoint_auth_methods_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'token_endpoint_auth_methods_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.token_endpoint_auth_methods_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the token_endpoint_auth_signing_alg_values_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the token_endpoint_auth_signing_alg_values_supported claim in the 'op' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.token_endpoint_auth_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the claims_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the claims_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.claims_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the claims_parameter_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the claims_parameter_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.claims_parameter_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the request_parameter_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the request_parameter_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.request_parameter_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the authorization_response_iss_parameter_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the authorization_response_iss_parameter_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.authorization_response_iss_parameter_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the jwks claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'jwks' parameter in the 'openid_provider' subclaim (metadata type) is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the jwks or signed_jwks_uri claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'jwks' or the 'signed_jwks_uri' parameter in the 'openid_provider' subclaim (metadata type) is checked. There must be at least one of the two",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.signed_jwks_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the client_registration_types_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the client_registration_types_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.client_registration_types_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the request_authentication_methods_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the request_authentication_methods_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.request_authentication_methods_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the request_authentication_signing_alg_values_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the request_authentication_signing_alg_values_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.request_authentication_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the iss parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the sub parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the iat parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the exp parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the jwks parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the metadata parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the metadata parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's entity configuration contain the authority_hints parameter",
        "description": "To accomplish this test, the Entity configuration of the OP is taken, the payload is decoded (Base64 encoding) and the presence of the authority_hints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.authority_hints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain the trust_marks parameter",
        "description": "To accomplish this test, the Entity configuration is taken, the payload is decoded (Base64 encoding) and the presence of the trust_marks parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'alg' parameter in the Header",
        "description": "In this test, the Access Token is taken from the Token Response, the header is base64url decoded and the presence of the 'alg' parameter in the Header is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'kid' parameter in the Header",
        "description": "The Access Token is taken from the Token Response and the presence of the 'kid' parameter in the Header is checked. If it is not present, than the Access Token is not compliant.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.kid",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'typ' parameter in the Header",
        "description": "The Access Token present in the Token response is analyzed and the presence of the 'typ' parameter in the header is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.typ",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'iss' parameter in the Payload",
        "description": "The Access Token present in the Token Response is analyzed and the presence of the 'iss' parameter in the Payload is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'sub' parameter in the Payload",
        "description": "The Access Token present in the Token Response is analyzed and the presence of the 'sub' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'client_id' parameter in the Payload",
        "description": "The Access Token present in the Token Response is analyzed and the presence of the 'client_id' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.client_id",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'aud' parameter in the Payload",
        "description": "The Access Token present in the Token Response is analyzed and the presence of the 'aud' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.aud",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the presence of aud in the client_assertion in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the aud parameter",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.aud",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the presence of exp in the client_assertion in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the exp parameter",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the presence of iss in the client_assertion in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the iss parameter",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the presence of iat in the client_assertion in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the iat parameter",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the presence of jti in the client_assertion in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the jti parameter",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jti",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the presence of sub in the client_assertion in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the sub parameter",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the presence of iss in the token in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the iss parameter",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=token=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the presence of sub in the token in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the sub parameter",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=token=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the presence of client_id in the token in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the client_id parameter",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=token=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.client_id",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the presence of aud in the token in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the aud parameter",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=token=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.aud",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the presence of scope in the token in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the scope parameter",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=token=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.scope",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the presence of iat in the token in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the iat parameter",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=token=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the presence of exp in the token in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the exp parameter",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=token=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the presence of jti in the token in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the jti parameter",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=token=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jti",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Revocation request in client_assertion JWT contain the 'aud' parameter",
        "description": "The Revocation request is taken, the JWT Token in the client_assertion parameter base64url decoded and the presence of the 'aud' parameter is checked. If it missing, than the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.aud",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Revocation request in client_assertion JWT contain the 'exp' parameter",
        "description": "The Revocation request is taken, the JWT Token in the client_assertion parameter base64url decoded and the presence of the 'exp' parameter is checked. If it missing, than the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Revocation request in client_assertion JWT contain the 'iss' parameter",
        "description": "The Revocation request is taken, the JWT Token in the client_assertion parameter base64url decoded and the presence of the 'iss' parameter is checked. If it missing, than the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Revocation request in client_assertion JWT contain the 'iat' parameter",
        "description": "The Revocation request is taken, the JWT Token in the client_assertion parameter base64url decoded and the presence of the 'iat' parameter is checked. If it missing, than the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Revocation request in client_assertion JWT contain the 'jti' parameter",
        "description": "The Revocation request is taken, the JWT Token in the client_assertion parameter base64url decoded and the presence of the 'jti' parameter is checked. If it missing, than the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jti",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Revocation request in client_assertion JWT contain the 'sub' parameter",
        "description": "The Revocation request is taken, the JWT Token in the client_assertion parameter base64url decoded and the presence of the 'sub' parameter is checked. If it missing, than the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "client_assertion",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'scope' parameter in the Payload",
        "description": "The Access Token present in the Token Response is analyzed and the presence of the 'scope' parameter in the Payload is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.scope",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'iat' parameter in the Payload",
        "description": "The Access Token present in the Token Response is analyzed and the presence of the 'iat' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'exp' parameter in the Payload",
        "description": "The Access Token present in the Token Response is analyzed and the presence of the 'exp' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'jti' parameter in the Payload",
        "description": "The Access Token present in the Token Response is analyzed and the presence of the 'jti' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jti",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain a correct 'alg' parameter in the Header",
        "description": "In this test, the ID Token is taken from the Token Response, the header is base64url decoded and the presence of the 'alg' parameter in the Header is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain the 'kid' parameter in the Header",
        "description": "The ID Token is taken from the Token Response and the presence of the 'kid' parameter in the Header is checked. If it is not present, than the ID Token is not compliant.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.kid",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain the 'iss' parameter in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'iss' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain the 'sub' parameter in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'sub' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain the 'aud' parameter in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'aud' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.aud",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain the 'acr' parameter in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'acr' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.acr",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does ID token payload contain the 'at_hash' parameter",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'at_hash' parameter in the Payload is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.at_hash",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain the 'iat' parameter in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'iat' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain the 'nbf' parameter in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'nbf' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.nbf",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain the 'exp' parameter in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'exp' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain the 'jti' parameter in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'jti' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jti",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain the 'nonce' parameter in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'nonce' parameter in the Payload is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.nonce",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Configuration",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Configuration Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_OP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP correctly sign the Access Token",
        "description": "Tokens issued by an OP must have the structure of JWT Tokens. In particular, this structure is composed by three base64url encoded strings separated by dots, namely the header, payload and signature. The signature is made using the OP's private key, in such a way to be decrypted using its public key. In this test a normal flow is performed and the obtained Access Token is analyzed. In order to test if the OP correctly signed the signature part of the JWT, the access token is passed to a signature verifier correctly configured",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "jwt check sig": "X_key_core_OP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP correctly sign the Access Token",
        "description": "Tokens issued by an OP must have the structure of JWT Tokens. In particular, this structure is composed by three base64url encoded strings separated by dots, namely the header, payload and signature. The signature is made using the OP's private key, in such a way to be decrypted using its public key. In this test a normal flow is performed and the obtained Access Token is analyzed. In order to test if the OP correctly signed the signature part of the JWT, the access token is passed to a signature verifier correctly configured",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "(?<=\"refresh_token\": \")[^\"]+",
                "type": "jwt",
                "jwt check sig": "X_key_core_OP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP correctly sign the ID Token",
        "description": "Tokens issued by an OP must have the structure of JWT Tokens. In particular, this structure is composed by three base64url encoded strings separated by dots, namely the header, payload and signature. The signature is made using the OP's private key, in such a way to be decrypted using its public key. In this test a normal flow is performed and the obtained ID Token is analyzed. In order to test if the OP correctly signed the signature part of the JWT, the third part of the string is taken and passed to a signature verifier correctly configured",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "jwt check sig": "X_key_core_OP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP correctly sign the Access Token",
        "description": "Tokens issued by an OP must have the structure of JWT Tokens. In particular, this structure is composed by three base64url encoded strings separated by dots, namely the header, payload and signature. The signature is made using the OP's private key, in such a way to be decrypted using its public key. In this test a normal flow is performed and the obtained Access Token is analyzed. In order to test if the OP correctly signed the signature part of the JWT, the access token is passed to a signature verifier correctly configured",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "jwt check sig": "X_key_core_OP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain a correctly signed trust_marks",
        "description": "To accomplish this test, the Entity configuration is taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_OP"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the /.well-known/openid-federation endpoint",
        "description": "In order to check the presence and correctness of the /.well-known/openid-federation endpoint, an HTTP GET request to the entity's endpoint is done and its entity configuration is expected as response.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the EC response",
        "description": "In this test a correct request to the entity's /.well-known/openid-federation endpoint is made and the response is analyzed. It must be an HTTP 200 OK response",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the resolve entity statement endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request containing the parameters 'sub', 'anchor' and 'type' is made to the entity's endpoint and an HTTP 200 OK response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Resolve Entity Statement response",
            "checks": [
              {
                "in": "body",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the HTTP status of a token response correct?",
        "description": "This test verifies whether the HTTP status of a token response is 200.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the HTTP status of a UserInfo response correct?",
        "description": "This test verifies whether the HTTP status of a UserInfo response is 200.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the revocation endpoint return an empty HTTP 200 OK response upon a correct revocation request",
        "description": "A correct flow is accomplished and, once received the token, a request is made to the revocation endpoint. The response is then analyzed and has to be an empty HTTP 200 OK",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation response",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Content-Type in a token response set correctly?",
        "description": "This test verifies the head Content-Type set to application/json in the token response.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check": "Content-Type",
                "is": "application/json"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token_type of a token response set correctly?",
        "description": "This test verifies whether the token_type of a token response is Bearer.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "body",
                "check": "token_type",
                "is": "Bearer"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct Content-Type in the EC response",
        "description": "In this test a correct request to the entity's /.well-known/openid-federation endpoint is made and the response is analyzed. It must have a Content-Type parameter set to application/entity-statement+jwt",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "checks": [
              {
                "in": "head",
                "url decode": false,
                "is": "application/entity-statement+jwt",
                "check param": "Content-Type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Content-Type of the UserInfo response set to 'application/jwt'",
        "description": "The Content-Type of the UserInfo response must be set to 'application/jwt' ",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "checks": [
              {
                "in": "head",
                "url decode": false,
                "is": "application/jwt",
                "check param": "Content-Type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain a correct 'alg' parameter in the Header",
        "description": "In this test, the Access Token is taken from the Token Response, the header is base64url decoded and the presence of the 'alg' parameter in the Header is checked. The value must be a supported asymmetric algorithm between [\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"]",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.alg",
                    "is in": [
                      "RS256",
                      "RS512",
                      "ES256",
                      "ES512",
                      "PS256",
                      "PS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'openid_relying_party'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "openid_relying_party.*(\\n.*)+\"openid_relying_party\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'openid_provider'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "openid_provider.*(\\n.*)+\"openid_provider\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'federation_entity'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "federation_entity.*(\\n.*)+\"federation_entity\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'oauth_authorization_server'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "oauth_authorization_server.*(\\n.*)+\"oauth_authorization_server\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one  'oauth_resource'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "oauth_resource.*(\\n.*)+\"oauth_resource\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the UserInfo Response's JWE contain a correct cty parameter in the JOSE Header",
        "description": "The JWE Token contained in the UserInfo response is taken and analyzed. If it contains the 'cty' parameter set to 'JWT' in the JOSE header, then it is compliant with the specification",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "decode operations": [
              {
                "jwe decrypt": "X_key_jwe",
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.cty",
                    "is": "JWT"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP issue refresh tokens even when it is not supposed to",
        "description": "In this test an RP makes an authentication request with an arbitrary scope that differs from 'offline_access'. Once received the code, the RP tries to exchange it in the token endpoint and the response must not contain the refresh token.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "body",
                "check": "refresh_token",
                "is present": false
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct iss parameter value",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked. It must identify the issuing entity.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is": "X_url_OP"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration OP contain a correct sub parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the sub parameter is checked. Its value must be equal to the one in the iss parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is": "X_url_OP"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the UserInfo Response's JWE contain a correct alg parameter in the JOSE Header",
        "description": "The JWE Token contained in the UserInfo response is taken and analyzed. If it contains the 'alg' parameter is a String in the JOSE header, then it is compliant with the specification",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "decode operations": [
              {
                "jwe decrypt": "-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC5d8kD7BOVMIDg\nV2ygTSpl+YoiB52Zquu1aBBsSUptaD1ENHtnwlUFpEsWrDJ/IbUkkWbrgbnVwEnA\nsgXBagXufGwf1VgubmhyMCexHhGGV9UTTL/rTCN/yyQmAFGmJdA+XAf2MMZqpUT8\n8QFM5sM7nDdei6sPUXfrT6/lwsMtEd0UkiK10RW2oBOpjkOCVENoqIGGKztrn/Vu\nTzf08MtpCGO7hcmTi28PLn4tWQzLmw/bNTr7W0l0D5WZoFktfL2fT3rsUYhaYzOl\np+sEw64cVxQ4fnqj5yUNqH8IhMfV2rYPrgrQxiESkAI7anwAfgrxDpi4nV2eRUMP\nBmnYLzixAgMBAAECggEBAJ/3jyuQ3TsagK3++bQxmlYmK1w6kVZPM8pdnXyookdH\nV0CSu7W8ybR6BkHh+BPrMN//gXOzimOw3GwVoB04ozEVo/S5ALvbgr6qhjGgK6Fh\n9GgXFJmQLDY3MlCMid/yUXDX1A4l951YOu6nuGVpzA6IKMGlWb92lyYgryhPGiSu\nAVf5xdzbeUes1GKY2UPE9Rg2Qld782t6oJQ613vM6HPqfHC7N6yZ+7TFUiVc5wiK\njn3jNVSINCN59m7m2DsfPLHJB7g53104kw5cquSMA8gR5oiHt36bvnOHtbYgZmzn\n9iKgwml/EnaZ1NoE4/WJWbUTapodzQf65LASli897iECgYEA5PA7lJEDd3vrw5hl\nolFzvjvRriOu1SMHXx9Y52AgpOeQ6MnE1pO8qwn33lwYTSPGYinaq4jS3FKF/U5v\nOZltJAGBMa4ByEvAROJVCh958rKVRWKIqVXLOi8Gk11kHbVKw6oDXAd8Qt/y/ff8\nk/K6jW2EbWm1K6kfTvTMzoHkqrUCgYEAz2QeMH4WtrdiWUET7JgZNX0TbcaVBgd2\nGpo8JHnfnGOUsvO/euKGgqpCcxiWVXSlqffQyTgVzl4iMROP8bEaQwvueHurtziM\nDSy9Suumyktu3PbGgjqu/izRim8Xlg7sz8Hs2quJPII/fQ8BCoaWpg30osFZqCBa\nrQM7CWhxR40CgYA3CVWZap8lu0G7XMiaE/C6O9E1htiB3pDoGjYaMW7Hle+tNsw+\nNXf2uke/Se6BpOcNNDigYh0m4CPb+F4ev7aQIFh5o/ZDu4o2RR7idxyu7qWZ740h\nAEIB88ol5R6rUajujtGN7zK9NO9KhLJQstqMI1bhorbuDxM6vPj7cBiTvQKBgQDJ\nfuJ+BuOWntHlGf97rcNAXsdTrs73TqSG8Ddi0S5ayb2dqIjvoctChJ2PKeJWIMEc\nRHQMLHuzR2489F60WnfDkIIfeTi7CSu5WTCI7C/e+C88bF8uBEolFfJ4Z7soxlN6\n/1Val7L8oSeCH+PJED6qE4EN6IFtghHXav4fA+SbuQKBgQCNy7q3MoBOxDlKOpSN\nChoYUfW0JvwJbyyaVYOVq0efGVobosAblE/IuwaoIuVgh8c4T3qZtwFcSpvfR5Qy\nSOWFs2QXN/P4ZvmiVpXK/9Tcnth2BThpb9apQCT2a/CYtrRiGNAVWKiK0U9QlN/w\n9fVBO/ZgdaXE4xqYOSceH14yrQ==\n-----END PRIVATE KEY-----\n",
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.alg",
                    "is in": ""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the UserInfo Response's JWE contain a correct alg parameter in the JOSE Header",
        "description": "The JWE Token contained in the UserInfo response is taken and analyzed. If it contains the 'alg' parameter containing a value among ['RSA-OAEP', 'RSA-OAEP-256', 'ECDH-ES', 'ECDH-ES+A128KW', 'ECDH-ES+A256KW'] in the JOSE header, then it is compliant with the specification",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "decode operations": [
              {
                "jwe decrypt": "-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC5d8kD7BOVMIDg\nV2ygTSpl+YoiB52Zquu1aBBsSUptaD1ENHtnwlUFpEsWrDJ/IbUkkWbrgbnVwEnA\nsgXBagXufGwf1VgubmhyMCexHhGGV9UTTL/rTCN/yyQmAFGmJdA+XAf2MMZqpUT8\n8QFM5sM7nDdei6sPUXfrT6/lwsMtEd0UkiK10RW2oBOpjkOCVENoqIGGKztrn/Vu\nTzf08MtpCGO7hcmTi28PLn4tWQzLmw/bNTr7W0l0D5WZoFktfL2fT3rsUYhaYzOl\np+sEw64cVxQ4fnqj5yUNqH8IhMfV2rYPrgrQxiESkAI7anwAfgrxDpi4nV2eRUMP\nBmnYLzixAgMBAAECggEBAJ/3jyuQ3TsagK3++bQxmlYmK1w6kVZPM8pdnXyookdH\nV0CSu7W8ybR6BkHh+BPrMN//gXOzimOw3GwVoB04ozEVo/S5ALvbgr6qhjGgK6Fh\n9GgXFJmQLDY3MlCMid/yUXDX1A4l951YOu6nuGVpzA6IKMGlWb92lyYgryhPGiSu\nAVf5xdzbeUes1GKY2UPE9Rg2Qld782t6oJQ613vM6HPqfHC7N6yZ+7TFUiVc5wiK\njn3jNVSINCN59m7m2DsfPLHJB7g53104kw5cquSMA8gR5oiHt36bvnOHtbYgZmzn\n9iKgwml/EnaZ1NoE4/WJWbUTapodzQf65LASli897iECgYEA5PA7lJEDd3vrw5hl\nolFzvjvRriOu1SMHXx9Y52AgpOeQ6MnE1pO8qwn33lwYTSPGYinaq4jS3FKF/U5v\nOZltJAGBMa4ByEvAROJVCh958rKVRWKIqVXLOi8Gk11kHbVKw6oDXAd8Qt/y/ff8\nk/K6jW2EbWm1K6kfTvTMzoHkqrUCgYEAz2QeMH4WtrdiWUET7JgZNX0TbcaVBgd2\nGpo8JHnfnGOUsvO/euKGgqpCcxiWVXSlqffQyTgVzl4iMROP8bEaQwvueHurtziM\nDSy9Suumyktu3PbGgjqu/izRim8Xlg7sz8Hs2quJPII/fQ8BCoaWpg30osFZqCBa\nrQM7CWhxR40CgYA3CVWZap8lu0G7XMiaE/C6O9E1htiB3pDoGjYaMW7Hle+tNsw+\nNXf2uke/Se6BpOcNNDigYh0m4CPb+F4ev7aQIFh5o/ZDu4o2RR7idxyu7qWZ740h\nAEIB88ol5R6rUajujtGN7zK9NO9KhLJQstqMI1bhorbuDxM6vPj7cBiTvQKBgQDJ\nfuJ+BuOWntHlGf97rcNAXsdTrs73TqSG8Ddi0S5ayb2dqIjvoctChJ2PKeJWIMEc\nRHQMLHuzR2489F60WnfDkIIfeTi7CSu5WTCI7C/e+C88bF8uBEolFfJ4Z7soxlN6\n/1Val7L8oSeCH+PJED6qE4EN6IFtghHXav4fA+SbuQKBgQCNy7q3MoBOxDlKOpSN\nChoYUfW0JvwJbyyaVYOVq0efGVobosAblE/IuwaoIuVgh8c4T3qZtwFcSpvfR5Qy\nSOWFs2QXN/P4ZvmiVpXK/9Tcnth2BThpb9apQCT2a/CYtrRiGNAVWKiK0U9QlN/w\n9fVBO/ZgdaXE4xqYOSceH14yrQ==\n-----END PRIVATE KEY-----\n",
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.alg",
                    "is in": [
                      "RSA-OAEP",
                      "RSA-OAEP-256",
                      "ECDH-ES",
                      "ECDH-ES+A128KW",
                      "ECDH-ES+A256KW"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the UserInfo Response's JWE contain a correct enc parameter in the JOSE Header",
        "description": "The JWE Token contained in the UserInfo response is taken and analyzed. If it contains the 'enc' parameter containing a value among ['A128CBC-HS256', 'A256CBC-HS512'] in the JOSE header, then it is compliant with the specification",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "decode operations": [
              {
                "jwe decrypt": "-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC5d8kD7BOVMIDg\nV2ygTSpl+YoiB52Zquu1aBBsSUptaD1ENHtnwlUFpEsWrDJ/IbUkkWbrgbnVwEnA\nsgXBagXufGwf1VgubmhyMCexHhGGV9UTTL/rTCN/yyQmAFGmJdA+XAf2MMZqpUT8\n8QFM5sM7nDdei6sPUXfrT6/lwsMtEd0UkiK10RW2oBOpjkOCVENoqIGGKztrn/Vu\nTzf08MtpCGO7hcmTi28PLn4tWQzLmw/bNTr7W0l0D5WZoFktfL2fT3rsUYhaYzOl\np+sEw64cVxQ4fnqj5yUNqH8IhMfV2rYPrgrQxiESkAI7anwAfgrxDpi4nV2eRUMP\nBmnYLzixAgMBAAECggEBAJ/3jyuQ3TsagK3++bQxmlYmK1w6kVZPM8pdnXyookdH\nV0CSu7W8ybR6BkHh+BPrMN//gXOzimOw3GwVoB04ozEVo/S5ALvbgr6qhjGgK6Fh\n9GgXFJmQLDY3MlCMid/yUXDX1A4l951YOu6nuGVpzA6IKMGlWb92lyYgryhPGiSu\nAVf5xdzbeUes1GKY2UPE9Rg2Qld782t6oJQ613vM6HPqfHC7N6yZ+7TFUiVc5wiK\njn3jNVSINCN59m7m2DsfPLHJB7g53104kw5cquSMA8gR5oiHt36bvnOHtbYgZmzn\n9iKgwml/EnaZ1NoE4/WJWbUTapodzQf65LASli897iECgYEA5PA7lJEDd3vrw5hl\nolFzvjvRriOu1SMHXx9Y52AgpOeQ6MnE1pO8qwn33lwYTSPGYinaq4jS3FKF/U5v\nOZltJAGBMa4ByEvAROJVCh958rKVRWKIqVXLOi8Gk11kHbVKw6oDXAd8Qt/y/ff8\nk/K6jW2EbWm1K6kfTvTMzoHkqrUCgYEAz2QeMH4WtrdiWUET7JgZNX0TbcaVBgd2\nGpo8JHnfnGOUsvO/euKGgqpCcxiWVXSlqffQyTgVzl4iMROP8bEaQwvueHurtziM\nDSy9Suumyktu3PbGgjqu/izRim8Xlg7sz8Hs2quJPII/fQ8BCoaWpg30osFZqCBa\nrQM7CWhxR40CgYA3CVWZap8lu0G7XMiaE/C6O9E1htiB3pDoGjYaMW7Hle+tNsw+\nNXf2uke/Se6BpOcNNDigYh0m4CPb+F4ev7aQIFh5o/ZDu4o2RR7idxyu7qWZ740h\nAEIB88ol5R6rUajujtGN7zK9NO9KhLJQstqMI1bhorbuDxM6vPj7cBiTvQKBgQDJ\nfuJ+BuOWntHlGf97rcNAXsdTrs73TqSG8Ddi0S5ayb2dqIjvoctChJ2PKeJWIMEc\nRHQMLHuzR2489F60WnfDkIIfeTi7CSu5WTCI7C/e+C88bF8uBEolFfJ4Z7soxlN6\n/1Val7L8oSeCH+PJED6qE4EN6IFtghHXav4fA+SbuQKBgQCNy7q3MoBOxDlKOpSN\nChoYUfW0JvwJbyyaVYOVq0efGVobosAblE/IuwaoIuVgh8c4T3qZtwFcSpvfR5Qy\nSOWFs2QXN/P4ZvmiVpXK/9Tcnth2BThpb9apQCT2a/CYtrRiGNAVWKiK0U9QlN/w\n9fVBO/ZgdaXE4xqYOSceH14yrQ==\n-----END PRIVATE KEY-----\n",
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.enc",
                    "is in": [
                      "A128CBC-HS256",
                      "A256CBC-HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP correctly contain the code parameter on redirect in a successful authentication",
        "description": "In order to check if the OP correctly handles a successful authentication request, a correct request is sent by a client and the behavior of the OP is analyzed. In particular, the client must be redirected to its redirect_uri and the redirect must have 'code' as query parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication response",
            "checks": [
              {
                "in": "head",
                "check param": "Location",
                "contains": "code"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP contain correct state parameter on redirect in a successful authentication",
        "description": "In order to check if the OP correctly handles a successful authentication request, a correct request is sent by a client and the behavior of the OP is analyzed. In particular, the client must be redirected to its redirect_uri and the redirect must have 'state' as query parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication response",
            "checks": [
              {
                "in": "head",
                "check param": "Location",
                "contains": "state"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP contain iss parameter on redirect in a successful authentication",
        "description": "In order to check if the OP correctly handles a successful authentication request, a correct request is sent by a client and the behavior of the OP is analyzed. In particular, the client must be redirected to its redirect_uri and the redirect must have 'iss' as query parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication response",
            "checks": [
              {
                "in": "head",
                "check param": "Location",
                "contains": "iss"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token response have Cache-Control set to 'no-store'",
        "description": "This test verifies the presence of Cache-Control set to 'no-store' in the token response.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "check param": "Cache-Control",
                "contains": "no-store"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the UserInfo Response's JWE contain the alg parameter in the JOSE Header",
        "description": "The JWE Token contained in the UserInfo response's body is taken and analyzed. If it contains the 'alg' parameter in the JOSE header, then it is compliant with the specification",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "decode operations": [
              {
                "jwe decrypt": "-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC5d8kD7BOVMIDg\nV2ygTSpl+YoiB52Zquu1aBBsSUptaD1ENHtnwlUFpEsWrDJ/IbUkkWbrgbnVwEnA\nsgXBagXufGwf1VgubmhyMCexHhGGV9UTTL/rTCN/yyQmAFGmJdA+XAf2MMZqpUT8\n8QFM5sM7nDdei6sPUXfrT6/lwsMtEd0UkiK10RW2oBOpjkOCVENoqIGGKztrn/Vu\nTzf08MtpCGO7hcmTi28PLn4tWQzLmw/bNTr7W0l0D5WZoFktfL2fT3rsUYhaYzOl\np+sEw64cVxQ4fnqj5yUNqH8IhMfV2rYPrgrQxiESkAI7anwAfgrxDpi4nV2eRUMP\nBmnYLzixAgMBAAECggEBAJ/3jyuQ3TsagK3++bQxmlYmK1w6kVZPM8pdnXyookdH\nV0CSu7W8ybR6BkHh+BPrMN//gXOzimOw3GwVoB04ozEVo/S5ALvbgr6qhjGgK6Fh\n9GgXFJmQLDY3MlCMid/yUXDX1A4l951YOu6nuGVpzA6IKMGlWb92lyYgryhPGiSu\nAVf5xdzbeUes1GKY2UPE9Rg2Qld782t6oJQ613vM6HPqfHC7N6yZ+7TFUiVc5wiK\njn3jNVSINCN59m7m2DsfPLHJB7g53104kw5cquSMA8gR5oiHt36bvnOHtbYgZmzn\n9iKgwml/EnaZ1NoE4/WJWbUTapodzQf65LASli897iECgYEA5PA7lJEDd3vrw5hl\nolFzvjvRriOu1SMHXx9Y52AgpOeQ6MnE1pO8qwn33lwYTSPGYinaq4jS3FKF/U5v\nOZltJAGBMa4ByEvAROJVCh958rKVRWKIqVXLOi8Gk11kHbVKw6oDXAd8Qt/y/ff8\nk/K6jW2EbWm1K6kfTvTMzoHkqrUCgYEAz2QeMH4WtrdiWUET7JgZNX0TbcaVBgd2\nGpo8JHnfnGOUsvO/euKGgqpCcxiWVXSlqffQyTgVzl4iMROP8bEaQwvueHurtziM\nDSy9Suumyktu3PbGgjqu/izRim8Xlg7sz8Hs2quJPII/fQ8BCoaWpg30osFZqCBa\nrQM7CWhxR40CgYA3CVWZap8lu0G7XMiaE/C6O9E1htiB3pDoGjYaMW7Hle+tNsw+\nNXf2uke/Se6BpOcNNDigYh0m4CPb+F4ev7aQIFh5o/ZDu4o2RR7idxyu7qWZ740h\nAEIB88ol5R6rUajujtGN7zK9NO9KhLJQstqMI1bhorbuDxM6vPj7cBiTvQKBgQDJ\nfuJ+BuOWntHlGf97rcNAXsdTrs73TqSG8Ddi0S5ayb2dqIjvoctChJ2PKeJWIMEc\nRHQMLHuzR2489F60WnfDkIIfeTi7CSu5WTCI7C/e+C88bF8uBEolFfJ4Z7soxlN6\n/1Val7L8oSeCH+PJED6qE4EN6IFtghHXav4fA+SbuQKBgQCNy7q3MoBOxDlKOpSN\nChoYUfW0JvwJbyyaVYOVq0efGVobosAblE/IuwaoIuVgh8c4T3qZtwFcSpvfR5Qy\nSOWFs2QXN/P4ZvmiVpXK/9Tcnth2BThpb9apQCT2a/CYtrRiGNAVWKiK0U9QlN/w\n9fVBO/ZgdaXE4xqYOSceH14yrQ==\n-----END PRIVATE KEY-----\n",
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the UserInfo Response's JWE contain the kid parameter in the JOSE Header",
        "description": "The JWE Token contained in the UserInfo response's body is taken and analyzed. If it contains the 'kid' parameter in the JOSE header, then it is compliant with the specification",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "decode operations": [
              {
                "jwe decrypt": "-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC5d8kD7BOVMIDg\nV2ygTSpl+YoiB52Zquu1aBBsSUptaD1ENHtnwlUFpEsWrDJ/IbUkkWbrgbnVwEnA\nsgXBagXufGwf1VgubmhyMCexHhGGV9UTTL/rTCN/yyQmAFGmJdA+XAf2MMZqpUT8\n8QFM5sM7nDdei6sPUXfrT6/lwsMtEd0UkiK10RW2oBOpjkOCVENoqIGGKztrn/Vu\nTzf08MtpCGO7hcmTi28PLn4tWQzLmw/bNTr7W0l0D5WZoFktfL2fT3rsUYhaYzOl\np+sEw64cVxQ4fnqj5yUNqH8IhMfV2rYPrgrQxiESkAI7anwAfgrxDpi4nV2eRUMP\nBmnYLzixAgMBAAECggEBAJ/3jyuQ3TsagK3++bQxmlYmK1w6kVZPM8pdnXyookdH\nV0CSu7W8ybR6BkHh+BPrMN//gXOzimOw3GwVoB04ozEVo/S5ALvbgr6qhjGgK6Fh\n9GgXFJmQLDY3MlCMid/yUXDX1A4l951YOu6nuGVpzA6IKMGlWb92lyYgryhPGiSu\nAVf5xdzbeUes1GKY2UPE9Rg2Qld782t6oJQ613vM6HPqfHC7N6yZ+7TFUiVc5wiK\njn3jNVSINCN59m7m2DsfPLHJB7g53104kw5cquSMA8gR5oiHt36bvnOHtbYgZmzn\n9iKgwml/EnaZ1NoE4/WJWbUTapodzQf65LASli897iECgYEA5PA7lJEDd3vrw5hl\nolFzvjvRriOu1SMHXx9Y52AgpOeQ6MnE1pO8qwn33lwYTSPGYinaq4jS3FKF/U5v\nOZltJAGBMa4ByEvAROJVCh958rKVRWKIqVXLOi8Gk11kHbVKw6oDXAd8Qt/y/ff8\nk/K6jW2EbWm1K6kfTvTMzoHkqrUCgYEAz2QeMH4WtrdiWUET7JgZNX0TbcaVBgd2\nGpo8JHnfnGOUsvO/euKGgqpCcxiWVXSlqffQyTgVzl4iMROP8bEaQwvueHurtziM\nDSy9Suumyktu3PbGgjqu/izRim8Xlg7sz8Hs2quJPII/fQ8BCoaWpg30osFZqCBa\nrQM7CWhxR40CgYA3CVWZap8lu0G7XMiaE/C6O9E1htiB3pDoGjYaMW7Hle+tNsw+\nNXf2uke/Se6BpOcNNDigYh0m4CPb+F4ev7aQIFh5o/ZDu4o2RR7idxyu7qWZ740h\nAEIB88ol5R6rUajujtGN7zK9NO9KhLJQstqMI1bhorbuDxM6vPj7cBiTvQKBgQDJ\nfuJ+BuOWntHlGf97rcNAXsdTrs73TqSG8Ddi0S5ayb2dqIjvoctChJ2PKeJWIMEc\nRHQMLHuzR2489F60WnfDkIIfeTi7CSu5WTCI7C/e+C88bF8uBEolFfJ4Z7soxlN6\n/1Val7L8oSeCH+PJED6qE4EN6IFtghHXav4fA+SbuQKBgQCNy7q3MoBOxDlKOpSN\nChoYUfW0JvwJbyyaVYOVq0efGVobosAblE/IuwaoIuVgh8c4T3qZtwFcSpvfR5Qy\nSOWFs2QXN/P4ZvmiVpXK/9Tcnth2BThpb9apQCT2a/CYtrRiGNAVWKiK0U9QlN/w\n9fVBO/ZgdaXE4xqYOSceH14yrQ==\n-----END PRIVATE KEY-----\n",
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.kid",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the UserInfo Response's JWE contain the enc parameter in the JOSE Header",
        "description": "The JWE Token contained in the UserInfo response's body is taken and analyzed. If it contains the 'enc' parameter in the JOSE header, then it is compliant with the specification",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "decode operations": [
              {
                "jwe decrypt": "-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC5d8kD7BOVMIDg\nV2ygTSpl+YoiB52Zquu1aBBsSUptaD1ENHtnwlUFpEsWrDJ/IbUkkWbrgbnVwEnA\nsgXBagXufGwf1VgubmhyMCexHhGGV9UTTL/rTCN/yyQmAFGmJdA+XAf2MMZqpUT8\n8QFM5sM7nDdei6sPUXfrT6/lwsMtEd0UkiK10RW2oBOpjkOCVENoqIGGKztrn/Vu\nTzf08MtpCGO7hcmTi28PLn4tWQzLmw/bNTr7W0l0D5WZoFktfL2fT3rsUYhaYzOl\np+sEw64cVxQ4fnqj5yUNqH8IhMfV2rYPrgrQxiESkAI7anwAfgrxDpi4nV2eRUMP\nBmnYLzixAgMBAAECggEBAJ/3jyuQ3TsagK3++bQxmlYmK1w6kVZPM8pdnXyookdH\nV0CSu7W8ybR6BkHh+BPrMN//gXOzimOw3GwVoB04ozEVo/S5ALvbgr6qhjGgK6Fh\n9GgXFJmQLDY3MlCMid/yUXDX1A4l951YOu6nuGVpzA6IKMGlWb92lyYgryhPGiSu\nAVf5xdzbeUes1GKY2UPE9Rg2Qld782t6oJQ613vM6HPqfHC7N6yZ+7TFUiVc5wiK\njn3jNVSINCN59m7m2DsfPLHJB7g53104kw5cquSMA8gR5oiHt36bvnOHtbYgZmzn\n9iKgwml/EnaZ1NoE4/WJWbUTapodzQf65LASli897iECgYEA5PA7lJEDd3vrw5hl\nolFzvjvRriOu1SMHXx9Y52AgpOeQ6MnE1pO8qwn33lwYTSPGYinaq4jS3FKF/U5v\nOZltJAGBMa4ByEvAROJVCh958rKVRWKIqVXLOi8Gk11kHbVKw6oDXAd8Qt/y/ff8\nk/K6jW2EbWm1K6kfTvTMzoHkqrUCgYEAz2QeMH4WtrdiWUET7JgZNX0TbcaVBgd2\nGpo8JHnfnGOUsvO/euKGgqpCcxiWVXSlqffQyTgVzl4iMROP8bEaQwvueHurtziM\nDSy9Suumyktu3PbGgjqu/izRim8Xlg7sz8Hs2quJPII/fQ8BCoaWpg30osFZqCBa\nrQM7CWhxR40CgYA3CVWZap8lu0G7XMiaE/C6O9E1htiB3pDoGjYaMW7Hle+tNsw+\nNXf2uke/Se6BpOcNNDigYh0m4CPb+F4ev7aQIFh5o/ZDu4o2RR7idxyu7qWZ740h\nAEIB88ol5R6rUajujtGN7zK9NO9KhLJQstqMI1bhorbuDxM6vPj7cBiTvQKBgQDJ\nfuJ+BuOWntHlGf97rcNAXsdTrs73TqSG8Ddi0S5ayb2dqIjvoctChJ2PKeJWIMEc\nRHQMLHuzR2489F60WnfDkIIfeTi7CSu5WTCI7C/e+C88bF8uBEolFfJ4Z7soxlN6\n/1Val7L8oSeCH+PJED6qE4EN6IFtghHXav4fA+SbuQKBgQCNy7q3MoBOxDlKOpSN\nChoYUfW0JvwJbyyaVYOVq0efGVobosAblE/IuwaoIuVgh8c4T3qZtwFcSpvfR5Qy\nSOWFs2QXN/P4ZvmiVpXK/9Tcnth2BThpb9apQCT2a/CYtrRiGNAVWKiK0U9QlN/w\n9fVBO/ZgdaXE4xqYOSceH14yrQ==\n-----END PRIVATE KEY-----\n",
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.enc",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the UserInfo Response's JWE contain the cty parameter in the JOSE Header",
        "description": "The JWE Token contained in the UserInfo response's body is taken and analyzed. If it contains the 'cty' parameter in the JOSE header, then it is compliant with the specification",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "decode operations": [
              {
                "jwe decrypt": "-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC5d8kD7BOVMIDg\nV2ygTSpl+YoiB52Zquu1aBBsSUptaD1ENHtnwlUFpEsWrDJ/IbUkkWbrgbnVwEnA\nsgXBagXufGwf1VgubmhyMCexHhGGV9UTTL/rTCN/yyQmAFGmJdA+XAf2MMZqpUT8\n8QFM5sM7nDdei6sPUXfrT6/lwsMtEd0UkiK10RW2oBOpjkOCVENoqIGGKztrn/Vu\nTzf08MtpCGO7hcmTi28PLn4tWQzLmw/bNTr7W0l0D5WZoFktfL2fT3rsUYhaYzOl\np+sEw64cVxQ4fnqj5yUNqH8IhMfV2rYPrgrQxiESkAI7anwAfgrxDpi4nV2eRUMP\nBmnYLzixAgMBAAECggEBAJ/3jyuQ3TsagK3++bQxmlYmK1w6kVZPM8pdnXyookdH\nV0CSu7W8ybR6BkHh+BPrMN//gXOzimOw3GwVoB04ozEVo/S5ALvbgr6qhjGgK6Fh\n9GgXFJmQLDY3MlCMid/yUXDX1A4l951YOu6nuGVpzA6IKMGlWb92lyYgryhPGiSu\nAVf5xdzbeUes1GKY2UPE9Rg2Qld782t6oJQ613vM6HPqfHC7N6yZ+7TFUiVc5wiK\njn3jNVSINCN59m7m2DsfPLHJB7g53104kw5cquSMA8gR5oiHt36bvnOHtbYgZmzn\n9iKgwml/EnaZ1NoE4/WJWbUTapodzQf65LASli897iECgYEA5PA7lJEDd3vrw5hl\nolFzvjvRriOu1SMHXx9Y52AgpOeQ6MnE1pO8qwn33lwYTSPGYinaq4jS3FKF/U5v\nOZltJAGBMa4ByEvAROJVCh958rKVRWKIqVXLOi8Gk11kHbVKw6oDXAd8Qt/y/ff8\nk/K6jW2EbWm1K6kfTvTMzoHkqrUCgYEAz2QeMH4WtrdiWUET7JgZNX0TbcaVBgd2\nGpo8JHnfnGOUsvO/euKGgqpCcxiWVXSlqffQyTgVzl4iMROP8bEaQwvueHurtziM\nDSy9Suumyktu3PbGgjqu/izRim8Xlg7sz8Hs2quJPII/fQ8BCoaWpg30osFZqCBa\nrQM7CWhxR40CgYA3CVWZap8lu0G7XMiaE/C6O9E1htiB3pDoGjYaMW7Hle+tNsw+\nNXf2uke/Se6BpOcNNDigYh0m4CPb+F4ev7aQIFh5o/ZDu4o2RR7idxyu7qWZ740h\nAEIB88ol5R6rUajujtGN7zK9NO9KhLJQstqMI1bhorbuDxM6vPj7cBiTvQKBgQDJ\nfuJ+BuOWntHlGf97rcNAXsdTrs73TqSG8Ddi0S5ayb2dqIjvoctChJ2PKeJWIMEc\nRHQMLHuzR2489F60WnfDkIIfeTi7CSu5WTCI7C/e+C88bF8uBEolFfJ4Z7soxlN6\n/1Val7L8oSeCH+PJED6qE4EN6IFtghHXav4fA+SbuQKBgQCNy7q3MoBOxDlKOpSN\nChoYUfW0JvwJbyyaVYOVq0efGVobosAblE/IuwaoIuVgh8c4T3qZtwFcSpvfR5Qy\nSOWFs2QXN/P4ZvmiVpXK/9Tcnth2BThpb9apQCT2a/CYtrRiGNAVWKiK0U9QlN/w\n9fVBO/ZgdaXE4xqYOSceH14yrQ==\n-----END PRIVATE KEY-----\n",
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.cty",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain a correct issuer parameter",
        "description": "In this test the OP metadata are taken and the presence of the 'issuer' parameter in the 'openid_provider' subclaim (metadata type) is checked to be the HTTPS URL of the OP",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.issuer",
                    "is in": [
                      "X_url_OP"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct revocation_endpoint_auth_methods_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'revocation_endpoint_auth_methods_supported' parameter in the 'openid_provider' subclaim (metadata type) is 'private_key_jwt'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.revocation_endpoint_auth_methods_supported",
                    "is in": [
                      "private_key_jwt"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct code_challenge_methods_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'code_challenge_methods_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked to be 'S256'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.code_challenge_methods_supported[0]",
                    "is in": [
                      "S256"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct scopes_supported claim",
        "description": "In this test the OP metadata are taken and the value of the 'scopes_supported' parameter in the 'openid_provider' subclaim (metadata type) is [openid, offline_access, profile, email]",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.scopes_supported[0]",
                    "is in": [
                      "openid",
                      "offline_access",
                      "profile",
                      "email"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct response_types_supported claim",
        "description": "In this test the OP metadata are taken and the presence of the 'response_types_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked. It must be present and must be set to 'code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.response_types_supported[0]",
                    "is in": [
                      "code"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct response_modes_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'response_modes_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked to be [form_post, query]",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.response_modes_supported[0]",
                    "is in": [
                      "form_post",
                      "query"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct grant_types_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'grant_types_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked to be [refresh_token, authorization_code]",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.grant_types_supported[0]",
                    "is in": [
                      "refresh_token",
                      "authorization_code"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct acr_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'acr_values_supported' in the 'openid_provider' subclaim (metadata type) parameter is checked to be [https://www.spid.gov.it/SpidL1, https://www.spid.gov.it/SpidL2, https://www.spid.gov.it/SpidL3]",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.acr_values_supported[0]",
                    "is in": [
                      "https://www.spid.gov.it/SpidL1",
                      "https://www.spid.gov.it/SpidL2",
                      "https://www.spid.gov.it/SpidL3"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct subject_types_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'subject_types_supported' parameter in the 'openid_provider' subclaim (metadata type) is 'pairwise'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.subject_types_supported[0]",
                    "is in": [
                      "pairwise"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct id_token_signing_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'id_token_signing_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked to be ['RS256', 'RS512', 'ES256', 'ES512', 'PS256', 'PS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.id_token_signing_alg_values_supported[0]",
                    "is in": [
                      "RS256",
                      "RS512",
                      "ES256",
                      "ES512",
                      "PS256",
                      "PS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct id_token_encryption_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'id_token_encryption_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked to be ['RSA-OAEP', 'RSA-OAEP-256']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.id_token_encryption_alg_values_supported[0]",
                    "is in": [
                      "RSA-OAEP",
                      "RSA-OAEP-256"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct id_token_encryption_enc_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'id_token_encryption_enc_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked to be ['A128CBC-HS256', 'A256CBC-HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.id_token_encryption_enc_values_supported[0]",
                    "is in": [
                      "A128CBC-HS256",
                      "A256CBC-HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct userinfo_signing_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'userinfo_signing_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is ['RS256', 'RS512', 'ES256', 'ES512', 'PS256', 'PS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.userinfo_signing_alg_values_supported[0]",
                    "is in": [
                      "RS256",
                      "RS512",
                      "ES256",
                      "ES512",
                      "PS256",
                      "PS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct userinfo_encryption_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'userinfo_encryption_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is ['RSA-OAEP', 'RSA-OAEP-256', 'ECDH-ES', 'ECDH-ES+A128KW', 'ECDH-ES+A256KW']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.userinfo_encryption_alg_values_supported[0]",
                    "is in": [
                      "RSA-OAEP",
                      "RSA-OAEP-256",
                      "ECDH-ES",
                      "ECDH-ES+A128KW",
                      "ECDH-ES+A256KW"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct userinfo_encryption_enc_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'userinfo_encryption_enc_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is ['A128CBC-HS256', 'A256CBC-HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.userinfo_encryption_enc_values_supported[0]",
                    "is in": [
                      "A128CBC-HS256",
                      "A256CBC-HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct request_object_signing_alg_values_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the value of the 'request_object_signing_alg_values_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked to be ['RS256', 'RS512', 'ES256', 'ES512', 'PS256', 'PS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.request_object_signing_alg_values_supported[0]",
                    "is in": [
                      "RS256",
                      "RS512",
                      "ES256",
                      "ES512",
                      "PS256",
                      "PS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the correct value of token_endpoint_auth_methods_supported claim in the openid_provider subclaim",
        "description": "In this test the OP metadata are taken and the presence of the 'token_endpoint_auth_methods_supported' parameter in the 'openid_provider' subclaim (metadata type) is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.token_endpoint_auth_methods_supported[0]",
                    "is in": [
                      "private_key_jwt"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct token_endpoint_auth_signing_alg_values_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the value of the token_endpoint_auth_signing_alg_values_supported claim in the 'openid_provider' entity type is checked to be ['RS256', 'RS512', 'ES256', 'ES512', 'PS256', 'PS512'].",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.token_endpoint_auth_signing_alg_values_supported[0]",
                    "is in": [
                      "RS256",
                      "RS512",
                      "ES256",
                      "ES512",
                      "PS256",
                      "PS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the correct value of client_registration_types_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the value of the client_registration_types_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.client_registration_types_supported[0]",
                    "is in": [
                      "automatic"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct request_authentication_signing_alg_values_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the value of the request_authentication_signing_alg_values_supported claim in the 'openid_provider' entity type is checked to ['RS256', 'RS512', 'ES256', 'ES512', 'PS256', 'PS512'].",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.request_authentication_signing_alg_values_supported[0]",
                    "is in": [
                      "RS256",
                      "RS512",
                      "ES256",
                      "ES512",
                      "PS256",
                      "PS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain correct value of 'acr' parameter valid in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'acr' parameter in the Payload is checked. Its value is one of ['https://www.spid.gov.it/SpidL1', 'https://www.spid.gov.it/SpidL2', 'https://www.spid.gov.it/SpidL3']. It must be equal or superior to the acr send from the RP in the Authentication Request.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.acr",
                    "is in": [
                      "https://www.spid.gov.it/SpidL1",
                      "https://www.spid.gov.it/SpidL2",
                      "https://www.spid.gov.it/SpidL3"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain correct value of 'at_hash' parameter is a String.",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'at_hash' parameter in the Payload is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.at_hash",
                    "is in": "{\"type\":\"object\",\"properties\":{\"at_hash\":{\"type\":\"string\"}},\"required\":[\"at_hash\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token response is sent?",
        "description": "This test verifies whether the token response is sent.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "is present": true,
                "check param": "HTTP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Content-Type in a token response set correctly?",
        "description": "This test verifies the head Content-Type set to application/json in the token response.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "is present": true,
                "check param": "Content-Type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token response have Cache-Control set to 'no-store'",
        "description": "This test verifies the presence of Cache-Control set to 'no-store' in the token response.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "head",
                "is present": true,
                "check param": "Cache-Control"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the successful token response contain access token",
        "description": "The Token response is analyzed and the presence of the access token is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "access_token"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the successful token response contain the token type",
        "description": "The RP receiving the Token response and that sent a correct token request must check the presence of the token_type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "token_type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP issue the expires_in in a token response",
        "description": "In this test an RP makes a correct authentication request and, once received the code, the RP tries to exchange it in the token endpoint. The response is then analyzed and it must contain the expires_in parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "expires_in"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the successful token response contain the ID token",
        "description": "The RP receiving the Token response and that sent a correct token request must check the presence of the ID token",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "id_token"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Content-Type be present in the UserInfo response",
        "description": "The Content-Type of the UserInfo response must be present",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "checks": [
              {
                "in": "head",
                "is present": true,
                "check param": "Content-Type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the HTTP status code of the UserInfo response is 200",
        "description": "A correct UserInfo request is made to the UserInfo endpoint (it must contain the parameter Authorization: Bearer <token> in the header) and the response analyzed. The HTTP code must be 200",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo response",
            "checks": [
              {
                "in": "head",
                "is present": true,
                "check param": "HTTP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Endpoint Response have the active parameter",
        "description": "To test that the Introspection response of the OP's correctly answers to valid tokens, a valid one is sent and the response is analyzed. It must contain the 'active' parameter",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection response",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "active"
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Endpoint returns true on active tokens",
        "description": "To test that the Introspection response of the OP's correctly identifies valid tokens, a valid one is sent and the response is analyzed",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection response",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "\"active\": true"
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Endpoint Response have the scope parameter",
        "description": "To test that the Introspection response of the OP's correctly answers to valid tokens, a valid one is sent and the response is analyzed. It must contain the scope parameter",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection response",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "\"scope\""
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Endpoint Response have the exp parameter",
        "description": "To test that the Introspection response of the OP's correctly answers to valid tokens, a valid one is sent and the response is analyzed. It must contain the exp parameter",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection response",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "\"exp\""
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Endpoint Response have the sub parameter",
        "description": "To test that the Introspection response of the OP's correctly answers to valid tokens, a valid one is sent and the response is analyzed. It must contain the sub parameter",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection response",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "\"sub\""
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Endpoint Response have the client_id parameter",
        "description": "To test that the Introspection response of the OP's correctly answers to valid tokens, a valid one is sent and the response is analyzed. It must contain the client_id parameter",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection response",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "\"client_id\""
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Endpoint Response have the iss parameter",
        "description": "To test that the Introspection response of the OP's correctly answers to valid tokens, a valid one is sent and the response is analyzed. It must contain the iss parameter",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection response",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "\"iss\""
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Endpoint Response have the aud parameter",
        "description": "To test that the Introspection response of the OP's correctly answers to valid tokens, a valid one is sent and the response is analyzed. It must contain the aud parameter",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection response",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "\"aud\""
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the HTTP method of the Revocation request",
        "description": "The revocation request must be sent via HTTP",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "checks": [
              {
                "in": "url",
                "is present": true,
                "check": "HTTP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the HTTP method of the Revocation request",
        "description": "The revocation request must be sent via HTTP POST",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "checks": [
              {
                "in": "url",
                "is present": true,
                "check": "POST"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct iss parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct iss parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct sub parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the sub parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct sub parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the sub parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain a correct iat parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain a correct exp parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct jwks parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the jwks parameter is checked. It must be JSON Object that contains keys, which is a JSON Array, which contains at least kty, which is a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct jwks parameter type for IT",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the jwks parameter is checked. It must contain at least KID.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}, \"kid\":{\"type\":\"string\"}},\"required\":[\"kty\", \"kid\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain a JSON Object",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"metadata\": {\"type\": \"object\"}}, \"required\": [\"metadata\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only allowed types",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "json schema compliant": "{\"type\": \"object\",\"anyOf\": [{\"required\": [\"openid_relying_party\"]},{\"required\": [\"openid_provider\"]},{\"required\": [\"federation_entity\"]},{\"required\": [\"oauth_authorization_server\"]},{\"required\": [\"oauth_resource\"]}],\"properties\": {\"openid_relying_party\":{\"type\":\"object\"},\"openid_provider\":{\"type\":\"object\"},\"federation_entity\":{\"type\":\"object\"},\"oauth_authorization_server\":{\"type\":\"object\"},\"oauth_resource\":{\"type\":\"object\"}}, \"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's entity configuration contain a correct authority_hints parameter",
        "description": "To accomplish this test, the Entity configuration of the OP is taken, the payload is decoded (Base64 encoding) and the authority_hints parameter is checked, it must be an array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"authority_hints\": {\"type\": \"array\", \"items\":{\"type\":\"string\"}}}, \"required\": [\"authority_hints\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's entity configuration contain a correct authority_hints parameter",
        "description": "To accomplish this test, the Entity configuration of the OP is taken, the payload is decoded (Base64 encoding) and the authority_hints parameter is checked, it must be an array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"authority_hints\": {\"type\": \"array\", \"items\":{\"type\":\"uri\"}}}, \"required\": [\"authority_hints\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain a correct trust_marks parameter",
        "description": "To accomplish this test, the Entity configuration is taken, the payload is decoded (Base64 encoding) and the type of the trust_marks parameter is checked. It must be an array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"trust_marks\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"array\"}}}, \"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain a correct trust_marks parameter value",
        "description": "To accomplish this test, the Entity configuration is taken, the payload is decoded (Base64 encoding) and the type of the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct organization_name claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the organization_name claim in the 'federation_entity' entity type is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"organization_name\": {\"type\": \"string\"}},\"required\": [\"organization_name\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct homepage_uri claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the homepage_uri claim in the 'federation_entity' entity type is checked. It must be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"homepage_uri\": {\"type\": \"string\",\"format\": \"uri\"}},\"required\": [\"homepage_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct policy_uri claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the policy_uri claim in the 'federation_entity' entity type is checked. It must be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"policy_uri\": {\"type\": \"string\",\"format\": \"uri\"}},\"required\": [\"policy_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain correct type logo_uri claim",
        "description": "In this test the metadata in the TA Entity Configuration are taken and the value of the logo_uri claim in the 'federation_entity' entity type is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"logo_uri\":{\"type\":\"string\"}},\"required\":[\"logo_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain a correct logo_uri claim",
        "description": "In this test the metadata in the TA Entity Configuration are taken and the value of the logo_uri claim in the 'federation_entity' entity type is an HTTPS URL with an .svg file",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"logo_uri\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://.*\\\\.svg$\"}},\"required\":[\"logo_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain correct type contacts claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the value of the contacts claim in the 'federation_entity' entity type is a JSON Array of String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"contacts\":{\"type\":\"array\", \"items\":{\"type\":\"string\"}}},\"required\":[\"contacts\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct federation_resolve_endpoint claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the federation_resolve_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_resolve_endpoint\": {\"type\": \"string\",\"format\": \"uri\", \"pattern\": \"^https://[^#]+$\"}},\"required\": [\"federation_resolve_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct federation_resolve_endpoint claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the federation_resolve_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL that ends with /trust_mark_status.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_resolve_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://.*/resolve\"}},\"required\": [\"federation_resolve_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain at least federation_entity and openid_provider",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the federation_entity and openid_provider is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_entity\": {\"type\": \"object\"},\"openid_provider\": {\"type\": \"object\"}},\"required\": [\"federation_entity\",\"openid_provider\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type issuer parameter",
        "description": "In this test the OP metadata are taken and the 'issuer' parameter in the 'openid_provider' subclaim (metadata type) is checked to be an HTTPS URL with no query or fragment component",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"issuer\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://\"}},\"required\":[\"issuer\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type authorization_endpoint parameter",
        "description": "In this test the OP metadata are taken and the 'authorization_endpoint' parameter in the 'openid_provider' subclaim (metadata type) is checked to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"authorization_endpoint\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://\"}},\"required\":[\"authorization_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type token_endpoint parameter",
        "description": "In this test the OP metadata are taken and the 'token_endpoint' parameter in the 'openid_provider' subclaim (metadata type) is checked to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"token_endpoint\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://\"}},\"required\":[\"token_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type userinfo_endpoint parameter",
        "description": "In this test the OP metadata are taken and the 'userinfo_endpoint' parameter in the 'openid_provider' subclaim (metadata type) is checked to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"userinfo_endpoint\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://\"}},\"required\":[\"userinfo_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type introspection_endpoint parameter",
        "description": "In this test the OP metadata are taken and the introspection_endpoint parameter in the 'openid_provider' subclaim (metadata type) is checked to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"introspection_endpoint\":{\"type\":\"string\", \"format\":\"uri\"}},\"required\":[\"introspection_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type introspection_endpoint parameter",
        "description": "In this test the OP metadata are taken and the 'introspection_endpoint' parameter in the 'openid_provider' subclaim (metadata type) is checked to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"introspection_endpoint\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://\"}},\"required\":[\"introspection_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type revocation_endpoint parameter",
        "description": "In this test the OP metadata are taken and the revocation_endpoint parameter in the 'openid_provider' subclaim (metadata type) is checked to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"revocation_endpoint\":{\"type\":\"string\", \"format\":\"uri\"}},\"required\":[\"revocation_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type revocation_endpoint parameter",
        "description": "In this test the OP metadata are taken and the 'revocation_endpoint' parameter in the 'openid_provider' subclaim (metadata type) is checked to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"revocation_endpoint\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://\"}},\"required\":[\"revocation_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type revocation_endpoint_auth_methods_supported parameter",
        "description": "In this test the OP metadata are taken and the revocation_endpoint_auth_methods_supported parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"revocation_endpoint_auth_methods_supported\":{\"type\":\"array\"}},\"required\":[\"revocation_endpoint_auth_methods_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type code_challenge_methods_supported parameter",
        "description": "In this test the OP metadata are taken and the code_challenge_methods_supported parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"code_challenge_methods_supported\":{\"type\":\"array\"}},\"required\":[\"code_challenge_methods_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type scopes_supported parameter",
        "description": "In this test the OP metadata are taken and the scopes_supported parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"scopes_supported\":{\"type\":\"array\"}},\"required\":[\"scopes_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type response_types_supported parameter",
        "description": "In this test the OP metadata are taken and the response_types_supported parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"response_types_supported\":{\"type\":\"array\"}},\"required\":[\"response_types_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type response_modes_supported parameter",
        "description": "In this test the OP metadata are taken and the response_modes_supported parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"response_modes_supported\":{\"type\":\"array\"}},\"required\":[\"response_modes_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type grant_types_supported parameter",
        "description": "In this test the OP metadata are taken and the grant_types_supported parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"grant_types_supported\":{\"type\":\"array\"}},\"required\":[\"grant_types_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type acr_values_supported parameter",
        "description": "In this test the OP metadata are taken and the acr_values_supported parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"acr_values_supported\":{\"type\":\"array\"}},\"required\":[\"acr_values_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type subject_types_supported parameter",
        "description": "In this test the OP metadata are taken and the subject_types_supported parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"subject_types_supported\":{\"type\":\"array\"}},\"required\":[\"subject_types_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type id_token_signing_alg_values_supported parameter",
        "description": "In this test the OP metadata are taken and the id_token_signing_alg_values_supported parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"id_token_signing_alg_values_supported\":{\"type\":\"array\"}},\"required\":[\"id_token_signing_alg_values_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type id_token_encryption_alg_values_supported parameter",
        "description": "In this test the OP metadata are taken and the id_token_encryption_alg_values_supported parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"id_token_encryption_alg_values_supported\":{\"type\":\"array\"}},\"required\":[\"id_token_encryption_alg_values_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type id_token_encryption_enc_values_supported parameter",
        "description": "In this test the OP metadata are taken and the id_token_encryption_enc_values_supported parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"id_token_encryption_enc_values_supported\":{\"type\":\"array\"}},\"required\":[\"id_token_encryption_enc_values_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type userinfo_signing_alg_values_supported parameter",
        "description": "In this test the OP metadata are taken and the userinfo_signing_alg_values_supported parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"userinfo_signing_alg_values_supported\":{\"type\":\"array\"}},\"required\":[\"userinfo_signing_alg_values_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type userinfo_encryption_alg_values_supported parameter",
        "description": "In this test the OP metadata are taken and the userinfo_encryption_alg_values_supported parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"userinfo_encryption_alg_values_supported\":{\"type\":\"array\"}},\"required\":[\"userinfo_encryption_alg_values_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type userinfo_encryption_enc_values_supported parameter",
        "description": "In this test the OP metadata are taken and the userinfo_encryption_enc_values_supported parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"userinfo_encryption_enc_values_supported\":{\"type\":\"array\"}},\"required\":[\"userinfo_encryption_enc_values_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type request_object_signing_alg_values_supported parameter",
        "description": "In this test the OP metadata are taken and the request_object_signing_alg_values_supported parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"request_object_signing_alg_values_supported\":{\"type\":\"array\"}},\"required\":[\"request_object_signing_alg_values_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type token_endpoint_auth_methods_supported parameter",
        "description": "In this test the OP metadata are taken and the token_endpoint_auth_methods_supported parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"token_endpoint_auth_methods_supported\":{\"type\":\"array\"}},\"required\":[\"token_endpoint_auth_methods_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type token_endpoint_auth_signing_alg_values_supported parameter",
        "description": "In this test the OP metadata are taken and the token_endpoint_auth_signing_alg_values_supported parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"token_endpoint_auth_signing_alg_values_supported\":{\"type\":\"array\"}},\"required\":[\"token_endpoint_auth_signing_alg_values_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type claims_supported parameter",
        "description": "In this test the OP metadata are taken and the claims_supported parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"claims_supported\":{\"type\":\"array\"}},\"required\":[\"claims_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type claims_parameter_supported parameter",
        "description": "In this test the OP metadata are taken and the claims_parameter_supported parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"claims_parameter_supported\":{\"type\":\"array\"}},\"required\":[\"claims_parameter_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the correct value of claims_parameter_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the claims_parameter_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": { \"claims_parameter_supported\": { \"type\": \"boolean\", \"const\": true}}, \"required\": [\"claims_parameter_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type request_parameter_supported parameter",
        "description": "In this test the OP metadata are taken and the request_parameter_supported parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"request_parameter_supported\":{\"type\":\"boolean\"}},\"required\":[\"request_parameter_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the correct value of request_parameter_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the request_parameter_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata.openid_provider.request_parameter_supported",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"request_parameter_supported\": {\"type\":\"boolean\", \"const\": true}}, \"required\": [\"request_parameter_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain correct type authorization_response_iss_parameter_supported parameter",
        "description": "In this test the OP metadata are taken and the authorization_response_iss_parameter_supported parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"authorization_response_iss_parameter_supported\":{\"type\":\"boolean\"}},\"required\":[\"authorization_response_iss_parameter_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the correct value of authorization_response_iss_parameter_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the authorization_response_iss_parameter_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata.openid_provider.authorization_response_iss_parameter_supported",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"authorization_response_iss_parameter_supported\": {\"type\":\"boolean\", \"const\": true}}, \"required\": [\"authorization_response_iss_parameter_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the correct jwks claim type",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the jwks claim in the 'openid_provider' entity type is checked. It must be a JSON Object that contains keys, which is a JSON Array, which contains at least kty, which is a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata.openid_provider.jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the correct jwks claim type",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the jwks claim in the 'openid_provider' entity type is checked. It must be a JSON Object that contains keys, which is a JSON Array, which contains kid, which is a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata.openid_provider.jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kid\":{\"type\":\"string\"}},\"required\":[\"kid\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain a correct type of signed_jwks_uri claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the type of the signed_jwks_uri claim in the 'openid_provider' entity type is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata.openid_provider",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"signed_jwks_uri\": {\"type\": \"string\", \"format\":\"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"signed_jwks_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain a correct type of client_registration_types_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the type of the client_registration_types_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata.openid_provider",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"client_registration_types_supported\": {\"type\": \"array\"}}, \"required\": [\"client_registration_types_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain a correct type of request_authentication_methods_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the type of the request_authentication_methods_supported claim in the 'openid_provider' entity type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata.openid_provider",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"request_authentication_methods_supported\": {\"type\": \"object\"}}, \"required\": [\"request_authentication_methods_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain the correct value of request_authentication_methods_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the presence of the request_authentication_methods_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider.request_authentication_methods_supported",
                    "json schema compliant": "{\"type\": \"object\",\"additionalProperties\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"const\": \"request_object\"}}}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP metadata contain a correct type of request_authentication_signing_alg_values_supported claim",
        "description": "In this test the OP metadata in the OP Entity Configuration are taken and the type of the request_authentication_signing_alg_values_supported claim in the 'openid_provider' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"request_authentication_signing_alg_values_supported\": {\"type\": \"array\"}}, \"required\": [\"request_authentication_signing_alg_values_supported\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token's 'iss' parameter contain an URL",
        "description": "The Access Token present in the Token Response is analyzed and the 'iss' parameter in the Payload is checked, in particular, its value must be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the correct 'sub' parameter type in the Payload.",
        "description": "The Access Token present in the Token Response is analyzed and the presence of the 'sub' parameter in the Payload is checked. It is a String MUST NOT exceed 255 ASCII Char.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"maxLength\": 255, \"pattern\": \"^[\\\\x00-\\\\x7F]*$\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'client_id' parameter in the Payload as an HTTPS url",
        "description": "The Access Token present in the Token Response is analyzed and the value of the 'client_id' parameter in the Payload must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"client_id\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"client_id\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain a correct 'aud' parameter",
        "description": "The Access Token present in the Token Response is analyzed and the value of the 'aud' parameter in the Payload is the identifier of the resource server",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"aud\":{\"type\":\"array\"}},\"required\":[\"aud\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the type of aud in the client_assertion in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the aud parameter. It must be JSON Array of String or single String",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"aud\":{\"oneOf\":[{\"type\":\"string\"},{\"type\":\"array\",\"items\":{\"type\":\"string\"}}]}},\"required\":[\"aud\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the type of exp in the client_assertion in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the exp parameter. It must be a Number",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the type of iss in the client_assertion in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the iss parameter. It must be a String",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\":[\"iss\"]})"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the type of iat in the client_assertion in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the iat parameter. It must be a Number",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the type of jti in the client_assertion in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the jti parameter. It must be JSON Array of String or single String",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"jti\": {\"type\": \"string\", \"pattern\": \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"}}, \"required\": [\"jti\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the type of sub in the client_assertion in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the sub parameter. It must be a String",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\":[\"sub\"]})"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the type of iss in the token in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the iss parameter. It must be a String",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=token=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\":[\"iss\"]})"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the type of sub in the token in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the sub parameter. It must be a String",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=token=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\":[\"sub\"]})"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the type of client_id in the token in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the client_id parameter. It must be a String",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=token=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"client_id\": {\"type\": \"string\"}}, \"required\":[\"client_id\"]})"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the type of aud in the token in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the aud parameter. It must be JSON Array of String or single String",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=token=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"aud\":{\"oneOf\":[{\"type\":\"string\"},{\"type\":\"array\",\"items\":{\"type\":\"string\"}}]}},\"required\":[\"aud\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the value of aud in the token in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the aud parameter. It must include the userinfo endpoint",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=token=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"aud\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"contains\":{\"type\":\"string\",\"pattern\":\"/userinfo\"}}},\"required\":[\"aud\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the type of iat in the token in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the iat parameter. It must be a Number",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=token=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the type of exp in the token in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the exp parameter. It must be a Number",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=token=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the OP verify the type of jti in the token in the Introspection request",
        "description": "Since the OP has to verify the client assertion in the Introspection Request, this test consist in intercepting a legitimate request, take the JWT of the client assertion and check the jti parameter. It must be JSON Array of String or single String",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=token=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"jti\": {\"type\": \"string\", \"pattern\": \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"}}, \"required\": [\"jti\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Revocation request in client_assertion JWT contain the correct type of 'aud' parameter",
        "description": "The Revocation request is taken, the JWT Token in the client_assertion parameter base64url decoded and the presence of the 'aud' parameter is checked. If it missing, than the RP is not compliant with the specifications. It must be a JSON Array of String or single String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"aud\":{\"oneOf\":[{\"type\":\"string\"},{\"type\":\"array\",\"items\":{\"type\":\"string\"}}]}},\"required\":[\"aud\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Revocation request in client_assertion JWT contain the correct type of 'exp' parameter",
        "description": "The Revocation request is taken, the JWT Token in the client_assertion parameter base64url decoded and the presence of the 'exp' parameter is checked. If it missing, than the RP is not compliant with the specifications. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Revocation request in client_assertion JWT contain the correct type of 'iss' parameter",
        "description": "The Revocation request is taken, the JWT Token in the client_assertion parameter base64url decoded and the presence of the 'iss' parameter is checked. If it missing, than the RP is not compliant with the specifications. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\":[\"iss\"]})"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Revocation request in client_assertion JWT contain the correct type of 'iat' parameter",
        "description": "The Revocation request is taken, the JWT Token in the client_assertion parameter base64url decoded and the presence of the 'iat' parameter is checked. If it missing, than the RP is not compliant with the specifications. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Revocation request in client_assertion JWT contain the correct type of 'jti' parameter",
        "description": "The Revocation request is taken, the JWT Token in the client_assertion parameter base64url decoded and the presence of the 'jti' parameter is checked. If it missing, than the RP is not compliant with the specifications. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"jti\": {\"type\": \"string\", \"pattern\": \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"}}, \"required\": [\"jti\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Revocation request in client_assertion JWT contain the correct type of 'sub' parameter",
        "description": "The Revocation request is taken, the JWT Token in the client_assertion parameter base64url decoded and the presence of the 'sub' parameter is checked. If it missing, than the RP is not compliant with the specifications. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\":[\"sub\"]})"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain a correct 'iat' parameter in the Payload",
        "description": "The Access Token present in the Token Response is analyzed and the presence of the 'iat' parameter in the Payload is a timestamp.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain a timestamp as the 'exp' parameter in the Payload",
        "description": "The Access Token present in the Token Response is analyzed and the presence of the 'exp' parameter in the Payload is checked. In particular, this parameter must be a valid timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'jti' parameter in the Payload in uuid4 format",
        "description": "The Access Token present in the Token Response is analyzed and the value of the 'jti' parameter in the Payload must be based on uuid4 format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"jti\": {\"type\": \"string\", \"pattern\": \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"}}, \"required\": [\"jti\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain the 'iss' parameter in the Payload as an HTTPS URL",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'iss' parameter has to be an HTTPS URL identifying the OP",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"const\": \"X_https_OP\"}}, \"required\":[\"iss\"]})"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain a correct 'sub' parameter in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the 'sub' parameter is checked to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"maxLength\": 255, \"pattern\": \"^[\\\\x00-\\\\x7F]*$\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Id Token contain a correct 'aud' parameter type",
        "description": "The Id Token present in the Token Response is analyzed and the value of the 'aud' parameter in the Payload is a JSON Array of String or single String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"aud\":{\"oneOf\":[{\"type\":\"string\"},{\"type\":\"array\",\"items\":{\"type\":\"string\"}}]}},\"required\":[\"aud\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain a correct 'iat' parameter in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'iat' parameter in the Payload is checked. In particular, its value must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=id_token: \")([^\"]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain a correct 'nbf' parameter type in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the presence of the 'nbf' parameter in the Payload is checked. In particular, its value must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=id_token: \")([^\"]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"nbf\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"nbf\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT ID Token contain a correct 'exp' parameter in the Payload",
        "description": "The ID Token present in the Token Response is taken, the payload is base64url decoded, analyzed and the type of the 'exp' parameter in the Payload is checked. In particular, its value must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=id_token: \")([^\"]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'jti' parameter in the Payload in String format",
        "description": "The Access Token present in the Token Response is analyzed and the value of the 'jti' parameter in the Payload must be based on String format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"jti\": {\"type\": \"string\"}}, \"required\": [\"jti\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued JWT Access Token contain the 'jti' parameter in the Payload in uuid4 format",
        "description": "The Access Token present in the Token Response is analyzed and the value of the 'jti' parameter in the Payload must be based on uuid4 format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"access_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"jti\": {\"type\": \"string\", \"pattern\": \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"}}, \"required\": [\"jti\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'nonce' parameter longer than 32 characters",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the value of the 'nonce' parameter must be at least 32 alphanumeric characters long.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token response",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=\"id_token\": \")[^\"]+",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$nonce",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"nonce\": {\"type\": \"string\", \"pattern\": \"^[\\u0020-\\u007E]{32,}$\"}}, \"required\": [\"nonce\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued intermediary Trust Mark contain the sa_profile claim",
        "description": "A Trust Mark issued by a TA for an SA is taken, decrypted and the presence of the sa_profile claim is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sa_profile",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the policy_uri claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "policy_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the policy_uri claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "policy_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the tos_uri claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "tos_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the tos_uri claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "tos_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the claims claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the claims claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "claims",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the claims claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the claims claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "claims",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the service_documentation claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "service_documentation",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the service_documentation claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "service_documentation",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration of a considered entity return a Federation Metadata in JOSE format when an HTTP GET request is made to its .well-known/openid-federation endpoint",
        "description": "The considered entity must have published its entity configuration in the .well-known/openid-federation endpoint. So in this test, an HTTP GET request is made to the entity's .well-known/openid-federation endpoint (appended to the URL which identifies the entity) and the response is analyzed. This response has to be the entity configuration of the entity and therefore a Federation Metadata in JOSE format (Content-Type: application/entity-statement+jwt)",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the resolve entity statement endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request containing the parameters 'sub', 'anchor' and 'type' is made to the entity's endpoint and an HTTP 200 OK response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Resolve Entity Statement response",
            "checks": [
              {
                "in": "body",
                "check regex": "[\\s*\"[^\"]*\"(?:,\\s*\"[^\"]*\")*\\s*\\]$",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the entity listing endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request to the entity's endpoint is done. A response containing a JSON list with the known Entity Identifiers is expected",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Listing response",
            "checks": [
              {
                "in": "body",
                "check regex": "\\[\\s*\"[^\"]*\"(?:,\\s*\"[^\"]*\")*\\s*\\]$",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the organization_name claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the organization_name claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.organization_name",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the homepage_uri claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the homepage_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.homepage_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the policy_uri claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the policy_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.policy_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the logo_uri claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the logo_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.logo_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the contacts claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the contacts claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.contacts",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the federation_resolve_endpoint claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the federation_resolve_endpoint claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_resolve_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA's metadata contain the federation_fetch_endpoint parameter",
        "description": "In this test the SA metadata are taken and the presence of the 'federation_fetch_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_fetch_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA's metadata contain the federation_list_endpoint parameter",
        "description": "In this test the SA metadata are taken and the presence of the 'federation_list_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_list_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA's metadata contain the federation_trust_mark_status_endpoint parameter",
        "description": "In this test the SA metadata are taken and the presence of the 'federation_trust_mark_status_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_trust_mark_status_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the iss parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the sub parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the iat parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the exp parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the jwks parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the metadata parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the metadata parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's entity configuration contain the authority_hints parameter",
        "description": "To accomplish this test, the Entity configuration of the OP is taken, the payload is decoded (Base64 encoding) and the presence of the authority_hints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.authority_hints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain the trust_marks parameter",
        "description": "To accomplish this test, the Entity configuration is taken, the payload is decoded (Base64 encoding) and the presence of the trust_marks parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA's metadata policy for an RP contain the jwks parameter",
        "description": "In order to check the compliance of a metadata policy issued by the SA, an entity statement for an RP must be fetched in the SA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the jwks parameter inside the openid_relying_party type is checked. It must contain the RP JWKS related to the OIDC Core operations",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.openid_relying_party.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Configuration",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Configuration Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_SA"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_TA"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_AA"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_OP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_RP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_TA"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_AA"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_OP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_RP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain a correctly signed trust_marks",
        "description": "To accomplish this test, the Entity configuration is taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_SA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_SA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_SA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_SA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_SA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_SA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_SA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_SA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_SA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the /.well-known/openid-federation endpoint",
        "description": "In order to check the presence and correctness of the /.well-known/openid-federation endpoint, an HTTP GET request to the entity's endpoint is done and its entity configuration is expected as response.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the EC response",
        "description": "In this test a correct request to the entity's /.well-known/openid-federation endpoint is made and the response is analyzed. It must be an HTTP 200 OK response",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the resolve entity statement endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request containing the parameters 'sub', 'anchor' and 'type' is made to the entity's endpoint and an HTTP 200 OK response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Resolve Entity Statement response",
            "checks": [
              {
                "in": "body",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued intermediary Trust Mark contain the sa_profile claim",
        "description": "A Trust Mark issued by a TA for an SA is taken, decrypted and the presence of the sa_profile claim is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \":  \"object \", \"properties \": { \"sa_profile\": { \"type \":  \"string \"}}, \"required \": [ \"sa_profile \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued intermediary Trust Mark contain a correct sa_profile claim",
        "description": "A Trust Mark issued for an SA is taken, decrypted and the value of the sa_profile claim can be 'full' or 'light'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"sa_profile\": { \"type \": \u00a0\"string \", \"enum \": [ \"full \", \u00a0\"light \"]}}, \"required \": [ \"sa_profile \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the policy_uri claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"policy_uri\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"policy_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the policy_uri claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"policy_uri\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"policy_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the policy_uri claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"policy_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"policy_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the policy_uri claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"policy_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"policy_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the tos_uri claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"tos_uri\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"tos_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the tos_uri claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"tos_uri\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"tos_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the tos_uri claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"tos_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"tos_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the tos_uri claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"tos_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"tos_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct claims claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the value of the claims claim is checked to be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"claims\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"claims\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct claims claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the value of the claims claim is checked to be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"claims\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"claims\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) is taken and the service_documentation claim is checked to be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"service_documentation\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"service_documentation\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) is taken and the service_documentation claim is checked to be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"service_documentation\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"service_documentation\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) is taken and the service_documentation claim is checked to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"service_documentation\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"service_documentation\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) is taken and the service_documentation claim is checked to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"service_documentation\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"service_documentation\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct Content-Type in the EC response",
        "description": "In this test a correct request to the entity's /.well-known/openid-federation endpoint is made and the response is analyzed. It must have a Content-Type parameter set to application/entity-statement+jwt",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "checks": [
              {
                "in": "head",
                "url decode": false,
                "is": "application/entity-statement+jwt",
                "check param": "Content-Type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'openid_relying_party'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "openid_relying_party.*(\\n.*)+\"openid_relying_party\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'openid_provider'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "openid_provider.*(\\n.*)+\"openid_provider\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'federation_entity'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "federation_entity.*(\\n.*)+\"federation_entity\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'oauth_authorization_server'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "oauth_authorization_server.*(\\n.*)+\"oauth_authorization_server\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one  'oauth_resource'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "oauth_resource.*(\\n.*)+\"oauth_resource\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct iss parameter value",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked. It must identify the issuing entity.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is": "X_url_SA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration OP contain a correct sub parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the sub parameter is checked. Its value must be equal to the one in the iss parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is": "X_url_SA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the entity listing endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request to the entity's endpoint is done. A response containing a JSON list with the known Entity Identifiers is expected",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Listing response",
            "checks": [
              {
                "in": "url",
                "is present": true,
                "check": "HTTP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct iss parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct iss parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct sub parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the sub parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct sub parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the sub parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain a correct iat parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain a correct exp parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct jwks parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the jwks parameter is checked. It must be JSON Object that contains keys, which is a JSON Array, which contains at least kty, which is a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct jwks parameter type for IT",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the jwks parameter is checked. It must contain at least KID.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}, \"kid\":{\"type\":\"string\"}},\"required\":[\"kty\", \"kid\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain a JSON Object",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"metadata\": {\"type\": \"object\"}}, \"required\": [\"metadata\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only allowed types",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "json schema compliant": "{\"type\": \"object\",\"anyOf\": [{\"required\": [\"openid_relying_party\"]},{\"required\": [\"openid_provider\"]},{\"required\": [\"federation_entity\"]},{\"required\": [\"oauth_authorization_server\"]},{\"required\": [\"oauth_resource\"]}],\"properties\": {\"openid_relying_party\":{\"type\":\"object\"},\"openid_provider\":{\"type\":\"object\"},\"federation_entity\":{\"type\":\"object\"},\"oauth_authorization_server\":{\"type\":\"object\"},\"oauth_resource\":{\"type\":\"object\"}}, \"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's entity configuration contain a correct authority_hints parameter",
        "description": "To accomplish this test, the Entity configuration of the OP is taken, the payload is decoded (Base64 encoding) and the authority_hints parameter is checked, it must be an array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"authority_hints\": {\"type\": \"array\", \"items\":{\"type\":\"string\"}}}, \"required\": [\"authority_hints\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's entity configuration contain a correct authority_hints parameter",
        "description": "To accomplish this test, the Entity configuration of the OP is taken, the payload is decoded (Base64 encoding) and the authority_hints parameter is checked, it must be an array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"authority_hints\": {\"type\": \"array\", \"items\":{\"type\":\"uri\"}}}, \"required\": [\"authority_hints\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain a correct trust_marks parameter",
        "description": "To accomplish this test, the Entity configuration is taken, the payload is decoded (Base64 encoding) and the type of the trust_marks parameter is checked. It must be an array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"trust_marks\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"array\"}}}, \"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain a correct trust_marks parameter value",
        "description": "To accomplish this test, the Entity configuration is taken, the payload is decoded (Base64 encoding) and the type of the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct organization_name claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the organization_name claim in the 'federation_entity' entity type is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"organization_name\": {\"type\": \"string\"}},\"required\": [\"organization_name\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct homepage_uri claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the homepage_uri claim in the 'federation_entity' entity type is checked. It must be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"homepage_uri\": {\"type\": \"string\",\"format\": \"uri\"}},\"required\": [\"homepage_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct policy_uri claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the policy_uri claim in the 'federation_entity' entity type is checked. It must be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"policy_uri\": {\"type\": \"string\",\"format\": \"uri\"}},\"required\": [\"policy_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain correct type logo_uri claim",
        "description": "In this test the metadata in the TA Entity Configuration are taken and the value of the logo_uri claim in the 'federation_entity' entity type is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"logo_uri\":{\"type\":\"string\"}},\"required\":[\"logo_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain a correct logo_uri claim",
        "description": "In this test the metadata in the TA Entity Configuration are taken and the value of the logo_uri claim in the 'federation_entity' entity type is an HTTPS URL with an .svg file",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"logo_uri\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://.*\\\\.svg$\"}},\"required\":[\"logo_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain correct type contacts claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the value of the contacts claim in the 'federation_entity' entity type is a JSON Array of String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"contacts\":{\"type\":\"array\", \"items\":{\"type\":\"string\"}}},\"required\":[\"contacts\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct federation_resolve_endpoint claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the federation_resolve_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_resolve_endpoint\": {\"type\": \"string\",\"format\": \"uri\", \"pattern\": \"^https://[^#]+$\"}},\"required\": [\"federation_resolve_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct federation_resolve_endpoint claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the federation_resolve_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL that ends with /trust_mark_status.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_resolve_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://.*/resolve\"}},\"required\": [\"federation_resolve_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA metadata contain at least federation_entity",
        "description": "In this test the SA metadata in the SA Entity Configuration are taken and the presence of the federation_entity is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_entity\": {\"type\": \"object\"}},\"required\": [\"federation_entity\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA metadata contain the correct federation_fetch_endpoint claim type",
        "description": "In this test the SA metadata in the SA Entity Configuration are taken and the presence of the federation_fetch_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_fetch_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://\"}},\"required\": [\"federation_fetch_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA metadata contain the correct federation_fetch_endpoint claim type",
        "description": "In this test the SA metadata in the SA Entity Configuration are taken and the presence of the federation_fetch_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL that ends with /trust_mark_status.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_fetch_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://.*/fetch\"}},\"required\": [\"federation_fetch_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA metadata contain the correct federation_list_endpoint claim type",
        "description": "In this test the SA metadata in the SA Entity Configuration are taken and the presence of the federation_list_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_trust_mark_status_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://\"}},\"required\": [\"federation_trust_mark_status_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA metadata contain the correct federation_list_endpoint claim type",
        "description": "In this test the SA metadata in the SA Entity Configuration are taken and the presence of the federation_list_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL that ends with /list.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_trust_mark_status_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://.*/list\"}},\"required\": [\"federation_trust_mark_status_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA metadata contain the correct federation_trust_mark_status_endpoint claim type",
        "description": "In this test the SA metadata in the SA Entity Configuration are taken and the presence of the federation_trust_mark_status_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_trust_mark_status_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\"}},\"required\": [\"federation_trust_mark_status_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA metadata contain the correct federation_trust_mark_status_endpoint claim type",
        "description": "In this test the SA metadata in the SA Entity Configuration are taken and the presence of the federation_trust_mark_status_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL that ends with /trust_mark_status.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_trust_mark_status_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://.*/trust_mark_status\"}},\"required\": [\"federation_trust_mark_status_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the metadata_policy parameter",
        "description": "In order to check if the entity issues correct Entity statements the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object and MUST contain [\"openid_relying_party\"]",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\", \"properties\": { \"openid_relying_party\": { \"type\": \"object\", \"additionalProperties\": true }}, \"required\": [\"openid_relying_party\"] } }, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the metadata_policy parameter",
        "description": "In order to check if the entity issues correct Entity statements the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object and MUST contain [\"openid_relying_party\"]",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\", \"properties\": { \"openid_relying_party\": { \"type\": \"object\", \"additionalProperties\": true }}, \"required\": [\"openid_relying_party\"] } }, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the metadata_policy parameter",
        "description": "In order to check if the entity issues correct Entity statements the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object and MUST contain [\"openid_relying_party\"]",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\", \"properties\": { \"openid_relying_party\": { \"type\": \"object\", \"additionalProperties\": true }}, \"required\": [\"openid_relying_party\"] } }, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the metadata_policy parameter",
        "description": "In order to check if the entity issues correct Entity statements the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object and MUST contain [\"openid_relying_party\"]",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\", \"properties\": { \"openid_relying_party\": { \"type\": \"object\", \"additionalProperties\": true }}, \"required\": [\"openid_relying_party\"] } }, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA's metadata policy for an RP contain the jwks parameter",
        "description": "In order to check the compliance of a metadata policy issued by the SA, an entity statement for an RP must be fetched in the SA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the jwks parameter inside the openid_relying_party type is checked. It must contain the RP JWKS related to the OIDC Core operations",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.jwks",
                    "json schema compliant": "{\"type\":\"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA's metadata policy for an RP contain the jwks parameter",
        "description": "In order to check the compliance of a metadata policy issued by the SA, an entity statement for an RP must be fetched in the SA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the jwks parameter inside the openid_relying_party type is checked. It must contain the RP JWKS related to the OIDC Core operations",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.jwks",
                    "json schema compliant": "{{\"type\":\"object\",\"properties\":{\"jwks\":{\"type\":\"object\",\"properties\":{\"value\":{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"items\":{\"type\":\"object\",\"properties\":{\"kty\":{\"type\":\"string\"},\"e\":{\"type\":\"string\"},\"use\":{\"type\":\"string\"},\"kid\":{\"type\":\"string\"},\"n\":{\"type\":\"string\"}}}}},\"required\":[\"keys\"]}},\"required\":[\"value\"]}},\"required\":[\"jwks\"]}}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued intermediary Trust Mark contain the sa_profile claim",
        "description": "A Trust Mark issued by a TA for an SA is taken, decrypted and the presence of the sa_profile claim is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sa_profile",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the policy_uri claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "policy_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the policy_uri claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "policy_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the tos_uri claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "tos_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the tos_uri claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "tos_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the claims claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the claims claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "claims",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the claims claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the claims claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "claims",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the service_documentation claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "service_documentation",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain the service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the presence of the service_documentation claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "service_documentation",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration of a considered entity return a Federation Metadata in JOSE format when an HTTP GET request is made to its .well-known/openid-federation endpoint",
        "description": "The considered entity must have published its entity configuration in the .well-known/openid-federation endpoint. So in this test, an HTTP GET request is made to the entity's .well-known/openid-federation endpoint (appended to the URL which identifies the entity) and the response is analyzed. This response has to be the entity configuration of the entity and therefore a Federation Metadata in JOSE format (Content-Type: application/entity-statement+jwt)",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the resolve entity statement endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request containing the parameters 'sub', 'anchor' and 'type' is made to the entity's endpoint and an HTTP 200 OK response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Resolve Entity Statement response",
            "checks": [
              {
                "in": "body",
                "check regex": "[\\s*\"[^\"]*\"(?:,\\s*\"[^\"]*\")*\\s*\\]$",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the entity listing endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request to the entity's endpoint is done. A response containing a JSON list with the known Entity Identifiers is expected",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Listing response",
            "checks": [
              {
                "in": "body",
                "check regex": "\\[\\s*\"[^\"]*\"(?:,\\s*\"[^\"]*\")*\\s*\\]$",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA publish the federation public key history",
        "description": "An HTTP Get request is made to the TA's /.well-known/openid-federation-jwks endpoint and the answer is analyzed",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Public Keys History response",
            "checks": [
              {
                "in": "body",
                "check regex": "\\[\\s*\"[^\"]*\"(?:,\\s*\"[^\"]*\")*\\s*\\]$",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain not valid values for the id_token_signed_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter inside the openid_relying_party type is checked. The key 'one_of' must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_signed_response_alg.one_of",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain not valid values for the id_token_encrypted_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter inside the openid_relying_party type is checked. The key 'one_of' must not contain the value ['RSA_1_5']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_encrypted_response_alg.one_of",
                    "not contains": [
                      "RSA_1_5"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain not valid values in the userinfo_signed_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter inside the openid_relying_party type is checked. The key 'one_of' must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_signed_response_alg.one_of",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain not valid values for the userinfo_encrypted_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the openid_relying_party type is checked. The key 'one_of' must not contain the value ['RSA_1_5']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_encrypted_response_alg.one_of",
                    "not contains": [
                      "RSA_1_5"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain not valid values for the id_token_signed_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter inside the intermediary type is checked. The key 'one_of' must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_signed_response_alg.one_of",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain not valid value for the id_token_encrypted_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter inside the intermediary type is checked. The key 'one_of' must not contain the value ['RSA_1_5']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encrypted_response_alg.one_of",
                    "not contains": [
                      "RSA_1_5"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain not valid values for the userinfo_signed_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter inside the intermediary type is checked. The key 'one_of' must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_signed_response_alg.one_of",
                    "not contains": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain not valid values for the userinfo_encrypted_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the intermediary type is checked. The key 'one_of' must not contain the value ['RSA_1_5']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encrypted_response_alg.one_of",
                    "not contains": [
                      "RSA_1_5"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the organization_name claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the organization_name claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.organization_name",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the homepage_uri claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the homepage_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.homepage_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the policy_uri claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the policy_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.policy_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the logo_uri claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the logo_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.logo_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the contacts claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the contacts claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.contacts",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the federation_resolve_endpoint claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the federation_resolve_endpoint claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_resolve_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata contain the federation_fetch_endpoint parameter",
        "description": "In this test the TA metadata are taken and the presence of the 'federation_fetch_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_fetch_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata contain the federation_list_endpoint parameter",
        "description": "In this test the TA metadata are taken and the presence of the 'federation_list_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_list_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata contain the federation_trust_mark_status_endpoint parameter",
        "description": "In this test the TA metadata are taken and the presence of the 'federation_trust_mark_status_endpoint' parameter inside the 'federation_entity' metadata type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_trust_mark_status_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Anchor's Entity configuration's constraints parameter contain the attribute 'max_path_length'",
        "description": "To accomplish this test, the Entity configuration of the TA is taken, the payload is decoded (Base64 encoding) and the presence of the constraints parameter is checked. It must contain the attribute max_path_length",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints.max_path_length",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the iss parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the sub parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the iat parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the exp parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the jwks parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the metadata parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the metadata parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's entity configuration contain the authority_hints parameter",
        "description": "To accomplish this test, the Entity configuration of the OP is taken, the payload is decoded (Base64 encoding) and the presence of the authority_hints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.authority_hints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain the trust_marks parameter",
        "description": "To accomplish this test, the Entity configuration is taken, the payload is decoded (Base64 encoding) and the presence of the trust_marks parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity configuration of the Trust Anchor contain the constraints parameter in its decoded payload",
        "description": "To accomplish this test, the Entity configuration of the TA is taken, the payload is decoded (Base64 encoding) and the presence of the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does TA's Entity configuration contain the trust_mark_issuers parameter",
        "description": "To accomplish this test, the Entity configuration of the TA is taken, the payload is decoded (Base64 encoding) and the presence of the trust_mark_issuers parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_mark_issuers",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the sub parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the jwks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the constraints parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the SA's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the constraints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.constraints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain the jwks parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the jwks parameter inside the openid_relying_party type is checked. It must contain the RP JWKS related to the OIDC Core operations",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy_openid_relying_party.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain grant_types parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.grant_types",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain id_token_signed_response_alg parameter ",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_signed_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_encrypted_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_encrypted_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_encrypted_response_enc parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_enc parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_encrypted_response_enc",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct userinfo_signed_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_signed_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct userinfo_encrypted_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the openid_relying_party type is checked. It must contain one_of=[\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_encrypted_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain the userinfo_encrypted_response_enc parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_enc parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_encrypted_response_enc",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct token_endpoint_auth_method parameter ",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_method parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.token_endpoint_auth_method",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct client_registration_types parameter ",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.client_registration_types",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct redirect_uris parameter presence",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the redirect_uris parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.redirect_uris",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct client_id parameter presence",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_id parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.client_id",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct response_types parameter presence",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.response_types",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain the grant_types parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types parameter inside the intermediary type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.grant_types",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain the id_token_signed_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter inside the intermediary type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.id_token_signed_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain the id_token_encrypted_response_alg parameter.",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter inside the intermediary type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.id_token_encrypted_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain the id_token_encrypted_response_enc parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_enc parameter inside the intermediary type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.id_token_encrypted_response_enc\")",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain the userinfo_signed_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter inside the intermediary type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.userinfo_signed_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain the userinfo_encrypted_response_alg parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the intermediary type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.userinfo_encrypted_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain the userinfo_encrypted_response_enc parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_enc parameter inside the intermediary type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.userinfo_encrypted_response_enc",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain the token_endpoint_auth_method parameter.",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_method parameter inside the intermediary type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.token_endpoint_auth_method",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain the client_registration_types parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types parameter inside the intermediary type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.client_registration_types",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct redirect_uris parameter presence",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the redirect_uris parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.redirect_uris",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct client_id parameter presence",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_id parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.client_id",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain the response_types parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types parameter inside the intermediary type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.openid_relying_party.response_types",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the jwks parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the jwks parameter inside the openid_provider type is checked. It must contain the RP JWKS related to the OIDC Core operations",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.openid_relying_party.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the revocation_endpoint_auth_methods_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the revocation_endpoint_auth_methods_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.revocation_endpoint_auth_methods_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the code_challenge_methods_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the code_challenge_methods_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.code_challenge_methods_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the scopes_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the scopes_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.scopes_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the response_types_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.response_types_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the response_modes_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_modes_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.response_modes_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the grant_types_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.grant_types_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the acr_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the acr_values_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.acr_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the subject_types_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the subject_types_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.subject_types_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the id_token_signing_alg_values_supported parameter.",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signing_alg_values_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.id_token_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the id_token_encryption_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encryption_alg_values_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encryption_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the id_token_encryption_enc_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encryption_enc_values_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.id_token_encryption_enc_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the userinfo_signing_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signing_alg_values_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.userinfo_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the userinfo_encryption_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encryption_alg_values_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.userinfo_encryption_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the userinfo_encryption_enc_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encryption_enc_values_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.userinfo_encryption_enc_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct token_endpoint_auth_methods_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_methods_supported parameter inside the openid_provider type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.openid_provider.token_endpoint_auth_methods_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the token_endpoint_auth_signing_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_signing_alg_values_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.token_endpoint_auth_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the claims_parameter_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the claims_parameter_supported parameter inside the openid_provider type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.claims_parameter_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the request_parameter_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the request_parameter_supported parameter inside the openid_provider type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_parameter_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the authorization_response_iss_parameter_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the authorization_response_iss_parameter_supported parameter inside the openid_provider type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.authorization_response_iss_parameter_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the client_registration_types_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types_supported parameter inside the openid_provider type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.client_registration_types_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the request_authentication_methods_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the request_authentication_methods_supported parameter inside the openid_provider type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_authentication_methods_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the request_authentication_signing_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the request_authentication_signing_alg_values_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.request_authentication_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the request_object_signing_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_object_signing_alg_values_supported parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.request_object_signing_alg_values_supported",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the issuer parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the issuer parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.issuer",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the authorization_endpoint parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the authorization_endpoint parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.authorization_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the token_endpoint parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the token_endpoint parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.token_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the userinfo_endpoint parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the userinfo_endpoint parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.userinfo_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the introspection_endpoint parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the introspection_endpoint parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.introspection_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the revocation_endpoint parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the revocation_endpoint parameter inside the openid_provider type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$..metadata_policy.intermediary.revocation_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct client_registration_types parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types parameter inside the intermediary type is checked. It must contain one_of=[\"automatic\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.client_registration_types",
                    "is subset of": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"automatic\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Configuration",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Configuration Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_TA"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_SA"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_AA"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_OP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_RP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_SA"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_AA"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_OP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Statement",
        "description": "To accomplish this test, the Entity Statement of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Statement Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_RP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain a correctly signed trust_marks",
        "description": "To accomplish this test, the Entity configuration is taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the SA correctly sign the Trust marks",
        "description": "To accomplish this test, an entity statement issued by the SA is taken, and the trust marks in it are taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the /.well-known/openid-federation endpoint",
        "description": "In order to check the presence and correctness of the /.well-known/openid-federation endpoint, an HTTP GET request to the entity's endpoint is done and its entity configuration is expected as response.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the EC response",
        "description": "In this test a correct request to the entity's /.well-known/openid-federation endpoint is made and the response is analyzed. It must be an HTTP 200 OK response",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the resolve entity statement endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request containing the parameters 'sub', 'anchor' and 'type' is made to the entity's endpoint and an HTTP 200 OK response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Resolve Entity Statement response",
            "checks": [
              {
                "in": "body",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the fetch entity statement endpoint",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the ES response",
        "description": "In order to check the presence and correctness of the fetch entity statement endpoint, an HTTP GET request containing the parameters 'iss' and 'sub' is made to the entity's endpoint and a response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. it must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked. It must have an email format.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued intermediary Trust Mark contain the sa_profile claim",
        "description": "A Trust Mark issued by a TA for an SA is taken, decrypted and the presence of the sa_profile claim is checked. It must be a string.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \":  \"object \", \"properties \": { \"sa_profile\": { \"type \":  \"string \"}}, \"required \": [ \"sa_profile \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued intermediary Trust Mark contain a correct sa_profile claim",
        "description": "A Trust Mark issued for an SA is taken, decrypted and the value of the sa_profile claim can be 'full' or 'light'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"sa_profile\": { \"type \": \u00a0\"string \", \"enum \": [ \"full \", \u00a0\"light \"]}}, \"required \": [ \"sa_profile \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the policy_uri claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"policy_uri\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"policy_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the policy_uri claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"policy_uri\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"policy_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the policy_uri claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"policy_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"policy_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct policy_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the policy_uri claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"policy_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"policy_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the tos_uri claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"tos_uri\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"tos_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the tos_uri claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"tos_uri\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"tos_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the tos_uri claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"tos_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"tos_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct tos_uri claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the tos_uri claim in it is checked. Its value has to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"tos_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"tos_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct claims claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the value of the claims claim is checked to be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"claims\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"claims\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct claims claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) must be taken, decrypted and the value of the claims claim is checked to be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"claims\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"claims\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) is taken and the service_documentation claim is checked to be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"service_documentation\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"service_documentation\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) is taken and the service_documentation claim is checked to be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"service_documentation\": {\"type\": \"string\", \"format\": \"uri-reference\"}}, \"required\": [\"service_documentation\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) is taken and the service_documentation claim is checked to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"service_documentation\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"service_documentation\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the issued oauth_resource Trust Mark contain a correct service_documentation claim",
        "description": "In this test, a Trust Mark issued for an AA (oauth_resource profile) is taken and the service_documentation claim is checked to be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"service_documentation\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"service_documentation\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct Content-Type in the EC response",
        "description": "In this test a correct request to the entity's /.well-known/openid-federation endpoint is made and the response is analyzed. It must have a Content-Type parameter set to application/entity-statement+jwt",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "checks": [
              {
                "in": "head",
                "url decode": false,
                "is": "application/entity-statement+jwt",
                "check param": "Content-Type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'openid_relying_party'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "openid_relying_party.*(\\n.*)+\"openid_relying_party\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'openid_provider'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "openid_provider.*(\\n.*)+\"openid_provider\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'federation_entity'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "federation_entity.*(\\n.*)+\"federation_entity\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'oauth_authorization_server'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "oauth_authorization_server.*(\\n.*)+\"oauth_authorization_server\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one  'oauth_resource'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "oauth_resource.*(\\n.*)+\"oauth_resource\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct iss parameter value",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked. It must identify the issuing entity.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is": "X_url_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration OP contain a correct sub parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the sub parameter is checked. Its value must be equal to the one in the iss parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is": "X_url_TA"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the entity listing endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request to the entity's endpoint is done. A response containing a JSON list with the known Entity Identifiers is expected",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Listing response",
            "checks": [
              {
                "in": "url",
                "is present": true,
                "check": "HTTP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct iss parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct iss parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct sub parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the sub parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct sub parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the sub parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain a correct iat parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain a correct exp parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct jwks parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the jwks parameter is checked. It must be JSON Object that contains keys, which is a JSON Array, which contains at least kty, which is a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct jwks parameter type for IT",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the jwks parameter is checked. It must contain at least KID.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}, \"kid\":{\"type\":\"string\"}},\"required\":[\"kty\", \"kid\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain a JSON Object",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"metadata\": {\"type\": \"object\"}}, \"required\": [\"metadata\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only allowed types",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "json schema compliant": "{\"type\": \"object\",\"anyOf\": [{\"required\": [\"openid_relying_party\"]},{\"required\": [\"openid_provider\"]},{\"required\": [\"federation_entity\"]},{\"required\": [\"oauth_authorization_server\"]},{\"required\": [\"oauth_resource\"]}],\"properties\": {\"openid_relying_party\":{\"type\":\"object\"},\"openid_provider\":{\"type\":\"object\"},\"federation_entity\":{\"type\":\"object\"},\"oauth_authorization_server\":{\"type\":\"object\"},\"oauth_resource\":{\"type\":\"object\"}}, \"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's entity configuration contain a correct authority_hints parameter",
        "description": "To accomplish this test, the Entity configuration of the OP is taken, the payload is decoded (Base64 encoding) and the authority_hints parameter is checked, it must be an array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"authority_hints\": {\"type\": \"array\", \"items\":{\"type\":\"string\"}}}, \"required\": [\"authority_hints\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's entity configuration contain a correct authority_hints parameter",
        "description": "To accomplish this test, the Entity configuration of the OP is taken, the payload is decoded (Base64 encoding) and the authority_hints parameter is checked, it must be an array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"authority_hints\": {\"type\": \"array\", \"items\":{\"type\":\"uri\"}}}, \"required\": [\"authority_hints\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain a correct trust_marks parameter",
        "description": "To accomplish this test, the Entity configuration is taken, the payload is decoded (Base64 encoding) and the type of the trust_marks parameter is checked. It must be an array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"trust_marks\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"array\"}}}, \"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain a correct trust_marks parameter value",
        "description": "To accomplish this test, the Entity configuration is taken, the payload is decoded (Base64 encoding) and the type of the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct organization_name claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the organization_name claim in the 'federation_entity' entity type is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"organization_name\": {\"type\": \"string\"}},\"required\": [\"organization_name\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct homepage_uri claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the homepage_uri claim in the 'federation_entity' entity type is checked. It must be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"homepage_uri\": {\"type\": \"string\",\"format\": \"uri\"}},\"required\": [\"homepage_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct policy_uri claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the policy_uri claim in the 'federation_entity' entity type is checked. It must be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"policy_uri\": {\"type\": \"string\",\"format\": \"uri\"}},\"required\": [\"policy_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain correct type logo_uri claim",
        "description": "In this test the metadata in the TA Entity Configuration are taken and the value of the logo_uri claim in the 'federation_entity' entity type is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"logo_uri\":{\"type\":\"string\"}},\"required\":[\"logo_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain a correct logo_uri claim",
        "description": "In this test the metadata in the TA Entity Configuration are taken and the value of the logo_uri claim in the 'federation_entity' entity type is an HTTPS URL with an .svg file",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"logo_uri\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://.*\\\\.svg$\"}},\"required\":[\"logo_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain correct type contacts claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the value of the contacts claim in the 'federation_entity' entity type is a JSON Array of String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"contacts\":{\"type\":\"array\", \"items\":{\"type\":\"string\"}}},\"required\":[\"contacts\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct federation_resolve_endpoint claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the federation_resolve_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_resolve_endpoint\": {\"type\": \"string\",\"format\": \"uri\", \"pattern\": \"^https://[^#]+$\"}},\"required\": [\"federation_resolve_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct federation_resolve_endpoint claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the federation_resolve_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL that ends with /trust_mark_status.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_resolve_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://.*/resolve\"}},\"required\": [\"federation_resolve_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA metadata contain at least federation_entity",
        "description": "In this test the TA metadata in the TA Entity Configuration are taken and the presence of the federation_entity is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_entity\": {\"type\": \"object\"}},\"required\": [\"federation_entity\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA metadata contain the correct federation_fetch_endpoint claim type",
        "description": "In this test the TA metadata in the TA Entity Configuration are taken and the presence of the federation_fetch_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_fetch_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://\"}},\"required\": [\"federation_fetch_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA metadata contain the correct federation_fetch_endpoint claim type",
        "description": "In this test the TA metadata in the TA Entity Configuration are taken and the presence of the federation_fetch_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL that ends with /trust_mark_status.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_fetch_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://.*/fetch\"}},\"required\": [\"federation_fetch_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA metadata contain the correct federation_list_endpoint claim type",
        "description": "In this test the TA metadata in the TA Entity Configuration are taken and the presence of the federation_list_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_trust_mark_status_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://\"}},\"required\": [\"federation_trust_mark_status_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA metadata contain the correct federation_list_endpoint claim type",
        "description": "In this test the TA metadata in the TA Entity Configuration are taken and the presence of the federation_list_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL that ends with /list.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_trust_mark_status_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://.*/list\"}},\"required\": [\"federation_trust_mark_status_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA metadata contain the correct federation_trust_mark_status_endpoint claim type",
        "description": "In this test the TA metadata in the TA Entity Configuration are taken and the presence of the federation_trust_mark_status_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_trust_mark_status_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\"}},\"required\": [\"federation_trust_mark_status_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA metadata contain the correct federation_trust_mark_status_endpoint claim type",
        "description": "In this test the TA metadata in the TA Entity Configuration are taken and the presence of the federation_trust_mark_status_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL that ends with /trust_mark_status.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_trust_mark_status_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://.*/trust_mark_status\"}},\"required\": [\"federation_trust_mark_status_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Anchor's Entity configuration contain a constraints parameter valued as a JSON Object with a max_path_length claim",
        "description": "To accomplish this test, the Entity configuration of the TA is taken, the payload is decoded (Base64 encoding) and the presence of the constraints parameter is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"constraints\": {\"type\": \"object\", \"properties\": {\"max_path_length\": {}}, \"required\": [\"max_path_length\"]}, \"required\": [\"constraints\"]}}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does TA's Entity configuration's trust_mark_issuers parameter contain a JSON Object of JSON Array",
        "description": "To accomplish this test, the Entity configuration of the TA is taken, the payload is decoded (Base64 encoding) and the trust_mark_issuers parameter must be a JSON Object of JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response TA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"trust_mark_issuers\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"array\"}}}, \"required\": [\"trust_mark_issuers\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the iss parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the iss parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be String.",
        "type": "passive",
        "sessions": [
          "SA non presente"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow SA non presente"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements contain the sub parameter",
        "description": "In order to check if the entity subues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the sub parameter is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct iat parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the iat parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain a correct exp parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response is base64url decoded and once obtained the decrypted Payload, the the exp parameter is checked. It must be a timestamp",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the SA contain the correct jwks parameter type",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence and type of the jwks parameter is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the trust_marks parameter",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload. It must be a JSON Array that contains JSON Objects.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": { \"type\": \"object\"}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the entity contain the correct trust_marks parameter values",
        "description": "In order to check if the entity issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements, a request for an entity statement is made (HTTP GET request in the entity's fetch endpoint) and the response is analyzed. Therefore, the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\"}, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object and MUST contain [\"openid_relying_party\", \"openid_provider\"]",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\", \"properties\": { \"openid_relying_party\": { \"type\": \"object\", \"additionalProperties\": true }, \"openid_provider\": { \"type\": \"object\", \"additionalProperties\": true } }, \"required\": [\"openid_relying_party\", \"openid_provider\"] } }, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object and MUST contain [\"openid_relying_party\", \"openid_provider\"]",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA AA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\", \"properties\": { \"openid_relying_party\": { \"type\": \"object\", \"additionalProperties\": true }, \"openid_provider\": { \"type\": \"object\", \"additionalProperties\": true } }, \"required\": [\"openid_relying_party\", \"openid_provider\"] } }, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object and MUST contain [\"openid_relying_party\", \"openid_provider\"]",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\", \"properties\": { \"openid_relying_party\": { \"type\": \"object\", \"additionalProperties\": true }, \"openid_provider\": { \"type\": \"object\", \"additionalProperties\": true } }, \"required\": [\"openid_relying_party\", \"openid_provider\"] } }, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does Entity Statements issued by the TA contain the metadata_policy parameter",
        "description": "In order to check if the TA issues correct Entity statements the Entity Statement Payload contained in the response are base64url decoded, once obtained the decrypted Payload, the presence if the metadata_policy parameter is checked. It must be a JSON Object and MUST contain [\"openid_relying_party\", \"openid_provider\"]",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"metadata_policy\": { \"type\": \"object\", \"properties\": { \"openid_relying_party\": { \"type\": \"object\", \"additionalProperties\": true }, \"openid_provider\": { \"type\": \"object\", \"additionalProperties\": true } }, \"required\": [\"openid_relying_party\", \"openid_provider\"] } }, \"required\": [\"metadata_policy\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain the jwks parameter as JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the jwks parameter inside the openid_relying_party type is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct grant_types parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types parameter type. Must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.grant_types",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct grant_types parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types parameter inside the openid_relying_party type is checked. It must contain: 'superset_of':[authorization_code], 'subset_of: [authorization_code, refresh_token]' and 'essential':true",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.grant_types",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"authorization_code\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"authorization_code\",\"refresh_token\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_signed_response_alg parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_signed_response_alg",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_signed_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter inside the openid_relying_party type is checked. It must contain one_of=[\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_signed_response_alg",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_encrypted_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_encrypted_response_alg",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_encrypted_response_alg parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter inside the openid_relying_party type is checked. It must contain one_of=[\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_encrypted_response_alg",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_encrypted_response_enc parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_enc parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_encrypted_response_enc",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_encrypted_response_enc parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_enc parameter inside the openid_relying_party type is checked. It must contain the key 'one_of' valued with ['A128CBC-HS256', 'A256CBC-HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_encrypted_response_enc",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"A128CBC-HS256\", \"A128CBC-HS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct userinfo_signed_response_alg parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_signed_response_alg",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct userinfo_signed_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter inside the openid_relying_party type is checked. It must contain one_of=[\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_signed_response_alg",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct userinfo_encrypted_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the openid_relying_party type is checked. It must contain one_of=[\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_encrypted_response_alg",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct userinfo_encrypted_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the openid_relying_party type is checked. It must contain one_of=[\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_encrypted_response_alg",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain the userinfo_encrypted_response_enc parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_enc parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_encrypted_response_enc",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain the userinfo_encrypted_response_enc parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_enc parameter inside the openid_relying_party type is checked. It must contain  'one_of': ['A128CBC-HS256', 'A256CBC-HS512'] and 'essential':true",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_encrypted_response_enc",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"A128CBC-HS256\", \"A128CBC-HS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct token_endpoint_auth_method parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_method parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.token_endpoint_auth_method",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct token_endpoint_auth_method parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_method parameter inside the openid_relying_party type is checked. It must contain the key 'one_of' valued with ['private_key']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.token_endpoint_auth_method",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"private_key_jwt\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct client_registration_types parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.client_registration_types",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct client_registration_types parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types parameter inside the openid_relying_party type is checked. It must contain 'one_of': ['automatic'] and 'essential':true",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.client_registration_types",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"automatic\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct redirect_uris parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the redirect_uris parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.redirect_uris",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct redirect_uris parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the redirect_uris parameter inside the openid_relying_party type is checked. It must contain {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.redirect_uris",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct client_id parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_id parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.client_id",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct client_id parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_id parameter inside the openid_relying_party type is checked. It must contain {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.client_id",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct response_types parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.response_types",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct response_types parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types parameter inside the openid_relying_party type is checked. It must contain the key 'value'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.response_types",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"value\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"code\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"value\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct grant_types parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types parameter inside the intermediary type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.grant_types",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct grant_types parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types parameter inside the intermediary type is checked. It must contain the key 'subset_of' values with ['authorization_code', 'refresh_token']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.grant_types",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"authorization_code\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"authorization_code\",\"refresh_token\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_signed_response_alg parameter type.",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter inside the intermediary type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_signed_response_alg",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_signed_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter inside the intermediary type is checked. It must contain one_of=[\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_signed_response_alg",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_encrypted_response_alg parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter inside the intermediary type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encrypted_response_alg",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_encrypted_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter inside the intermediary type is checked. It must contain one_of=[\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encrypted_response_alg",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_encrypted_response_enc parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_enc parameter inside the intermediary type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encrypted_response_enc",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_encrypted_response_enc parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_enc parameter inside the intermediary type is checked. It must contain one_of=[\"A128CBC-HS256\", \"A128CBC-HS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encrypted_response_enc",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"A128CBC-HS256\", \"A128CBC-HS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_signed_response_alg parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter inside the intermediary type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_signed_response_alg",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_signed_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter inside the intermediary type is checked. It must contain one_of=[\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_signed_response_alg",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_encrypted_response_alg parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the intermediary type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encrypted_response_alg",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_encrypted_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the intermediary type is checked. It must contain one_of=[\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encrypted_response_alg",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_encrypted_response_enc parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_enc parameter inside the intermediary type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encrypted_response_enc",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_encrypted_response_enc parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_enc parameter inside the intermediary type is checked. It must contain one_of=[\"A128CBC-HS256\", \"A128CBC-HS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encrypted_response_enc",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"A128CBC-HS256\", \"A128CBC-HS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct token_endpoint_auth_method parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_method parameter inside the intermediary type is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.token_endpoint_auth_method",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct token_endpoint_auth_method parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_method parameter inside the intermediary type is checked. It must contain one_of=[\"private_key_jwt\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.token_endpoint_auth_method",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"one_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"private_key_jwt\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"one_of\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct client_registration_types parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types parameter inside the intermediary type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata_policy.intermediary.client_registration_types",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct redirect_uris parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the redirect_uris parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.redirect_uris",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct redirect_uris parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the redirect_uris parameter inside the openid_relying_party type is checked. It must contain {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.redirect_uris",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct client_id parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_id parameter type",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.client_id",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct client_id parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_id parameter inside the openid_relying_party type is checked. It must contain {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.client_id",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct response_types parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types parameter inside the intermediary type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.response_types",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct response_types parameter key",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types parameter inside the intermediary type is checked. It must contain the key 'value' with value 'code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.response_types",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"value\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"code\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"value\",\"essential\"],\"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the correct jwks parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the jwks parameter inside the openid_provider type is checked. It must be a JSON Object that contains keys, a JSON Array, which contains at least kty, a string.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct revocation_endpoint_auth_methods_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the revocation_endpoint_auth_methods_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.revocation_endpoint_auth_methods_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct revocation_endpoint_auth_methods_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the revocation_endpoint_auth_methods_supported parameter inside the openid_provider type is checked. It must contain subset_of=[\"private_key_jwt\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.revocation_endpoint_auth_methods_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"private_key_jwt\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct code_challenge_methods_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the code_challenge_methods_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.code_challenge_methods_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct code_challenge_methods_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the code_challenge_methods_supported parameter inside the openid_provider type is checked. It must contain subset_of=[\"S256\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.code_challenge_methods_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"S256\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct scopes_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the scopes_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.scopes_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct scopes_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the scopes_supported parameter inside the openid_provider type is checked. It must contain superset_of=[\"openid\", \"offline_access\"] AND subset_of=[\"openid\", \"offline_access\", \"profile\", \"email\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.scopes_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"openid\",\"offline_access\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"openid\",\"offline_access\",\"profile\",\"email\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct response_types_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.response_types_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct response_types_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types_supported parameter inside the openid_provider type is checked. It must contain subset_of=[\"code\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.response_types_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"const\": [\"code\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct response_modes_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_modes_supported parameter inside the openid_provider type is checked. It must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.response_modes_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct response_modes_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_modes_supported parameter inside the openid_provider type is checked. It must contain superset_of=[\"form_post\", \"query\"] AND subset_of=[\"form_post\", \"query\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.response_modes_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"form_post\",\"query\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"form_post\",\"query\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct grant_types_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.grant_types_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct grant_types_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types_supported parameter inside the openid_provider type is checked. It must contain superset_of=[\"refresh_token\", \"authorization_code\"] AND subset_of=[\"refresh_token\", \"authorization_code\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.grant_types_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"refresh_token\",\"authorization_code\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"refresh_token\",\"authorization_code\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct acr_values_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the acr_values_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.acr_values_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct acr_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the acr_values_supported parameter inside the openid_provider type is checked. It must contain superset_of=[\"https://www.spid.gov.it/SpidL1\", \"https://www.spid.gov.it/SpidL2\"] AND subset_of=[\"https://www.spid.gov.it/SpidL1\", \"https://www.spid.gov.it/SpidL2\", \"https://www.spid.gov.it/SpidL3\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.acr_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"https://www.spid.gov.it/SpidL1\",\"https://www.spid.gov.it/SpidL2\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"https://www.spid.gov.it/SpidL1\",\"https://www.spid.gov.it/SpidL2\", \"https://www.spid.gov.it/SpidL3\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct subject_types_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the subject_types_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.subject_types_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct subject_types_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the subject_types_supported parameter inside the openid_provider type is checked. It must contain subset_of=[\"pairwise\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.subject_types_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"const\": [\"pairwise\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_signing_alg_values_supported parameter type.",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signing_alg_values_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_signing_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain superset_of=[\"RS256\", \"RS512\"], subset_of=[\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\",\"RS512\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\",\"RS512\", \"ES256\", \"ES512\", \"PS256\",\"PS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain not valid values for the id_token_signing_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signing_alg_values_supported parameter inside the openid_provider type is checked. The keys must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata_policy.intermediary.id_token_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"not\": {\"contains\": {\"enum\": [\"none\",\"HS256\",\"HS384\",\"HS512\"]}}},\"subset_of\": {\"not\": {\"contains\": {\"enum\": [\"none\",\"HS256\",\"HS384\",\"HS512\"]}}}},\"required\": [\"superset_of\",\"subset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_encryption_alg_values_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encryption_alg_values_supported parameter inside the openid_provider type is checked. Must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata_policy.intermediary.id_token_encryption_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_encryption_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encryption_alg_values_supported parameter inside the openid_provider type is checked. Must contain superset_of=[\"RSA-OAEP\", \"RSA-OAEP-256\"], subset_of=[\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata_policy.intermediary.id_token_encryption_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RSA-OAEP\",\"RSA-OAEP-256\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RSA-OAEP\",\"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_encryption_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encryption_alg_values_supported parameter inside the openid_provider type is checked. Must not contain the value ['RSA_1_5']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata_policy.intermediary.id_token_encryption_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"not\": {\"contains\": {\"enum\": [\"RSA_1_5\"]}}},\"subset_of\": {\"not\": {\"contains\": {\"enum\": [\"RSA_1_5\"]}}}},\"required\": [\"superset_of\",\"subset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_encryption_enc_values_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encryption_enc_values_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encryption_enc_values_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_encryption_enc_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encryption_enc_values_supported parameter inside the openid_provider type is checked. It must contain superset_of=[\"A128CBC-HS256\", \"A128CBC-HS512\"], subset_of=[\"A128CBC-HS256\", \"A128CBC-HS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encryption_enc_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"A128CBC-HS256\",\"A128CBC-HS512\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"A128CBC-HS256\",\"A128CBC-HS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_signing_alg_values_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signing_alg_values_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_signing_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain superset_of=[\"RS256\", \"RS512\"], subset_of=[\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\",\"RS512\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\",\"RS512\", \"ES256\", \"ES512\", \"PS256\",\"PS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain not valid values for the userinfo_signing_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signing_alg_values_supported parameter inside the openid_provider type is checked. The must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"not\": {\"contains\": {\"enum\": [\"none\",\"HS256\",\"HS384\",\"HS512\"]}}},\"subset_of\": {\"not\": {\"contains\": {\"enum\": [\"none\",\"HS256\",\"HS384\",\"HS512\"]}}}},\"required\": [\"superset_of\",\"subset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_encryption_alg_values_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encryption_alg_values_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encryption_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_encryption_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encryption_alg_values_supported parameter inside the openid_provider type is checked. It must contain superset_of=[\"RSA-OAEP\", \"RSA-OAEP-256\"], subset_of=[\"RSA-OAEP\", \"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encryption_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RSA-OAEP\",\"RSA-OAEP-256\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RSA-OAEP\",\"RSA-OAEP-256\", \"ECDH-ES\", \"ECDH-ES+A128KW\", \"ECDH-ES+A256KW\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain not valid values for the userinfo_encryption_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encryption_alg_values_supported parameter inside the openid_provider type is checked. Must not contain the value ['RSA_1_5']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encryption_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"not\": {\"contains\": {\"enum\": [\"RSA_1_5\"]}}},\"subset_of\": {\"not\": {\"contains\": {\"enum\": [\"RSA_1_5\"]}}}},\"required\": [\"superset_of\",\"subset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_encryption_enc_values_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encryption_enc_values_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encryption_enc_values_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_encryption_enc_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encryption_enc_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' valued with ['A128CBC-HS256', 'A256CBC-HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encryption_enc_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"A128CBC-HS256\",\"A128CBC-HS512\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"A128CBC-HS256\",\"A128CBC-HS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the token_endpoint_auth_methods_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the token_endpoint_auth_methods_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.token_endpoint_auth_methods_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the token_endpoint_auth_methods_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the token_endpoint_auth_methods_supported parameter inside the openid_provider type is checked. It must contain subset_of=[\"private_key_jwt\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.token_endpoint_auth_methods_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"private_key_jwt\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct token_endpoint_auth_signing_alg_values_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_signing_alg_values_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.token_endpoint_auth_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct token_endpoint_auth_signing_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain superset_of=[\"RS256\", \"RS512\"], subset_of=[\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.token_endpoint_auth_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\",\"RS512\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\",\"RS512\", \"ES256\", \"ES512\", \"PS256\",\"PS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain not valid values for the token_endpoint_auth_signing_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_signing_alg_values_supported parameter inside the openid_provider type is checked. The key 'subset_of' must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.token_endpoint_auth_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"not\": {\"contains\": {\"enum\": [\"none\",\"HS256\",\"HS384\",\"HS512\"]}}},\"subset_of\": {\"not\": {\"contains\": {\"enum\": [\"none\",\"HS256\",\"HS384\",\"HS512\"]}}}},\"required\": [\"superset_of\",\"subset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct claims_parameter_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the claims_parameter_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.claims_parameter_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct claims_parameter_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the claims_parameter_supported parameter inside the openid_provider type is checked. It must contain value=true AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.claims_parameter_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"value\": {\"type\": \"boolean\",\"const\": true},  \"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"value\",  \"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_parameter_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_parameter_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_parameter_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_parameter_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_parameter_supported parameter inside the openid_provider type is checked. It must contain value=true AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_parameter_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"value\": {\"type\": \"boolean\",\"const\": true},  \"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"value\",  \"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct authorization_response_iss_parameter_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the authorization_response_iss_parameter_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.authorization_response_iss_parameter_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct authorization_response_iss_parameter_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the authorization_response_iss_parameter_supported parameter inside the openid_provider type is checked. It must contain value=true AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.authorization_response_iss_parameter_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"value\": {\"type\": \"boolean\",\"const\": true},  \"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"value\",  \"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct client_registration_types_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the client_registration_types_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.client_registration_types_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct client_registration_types_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the client_registration_types_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' and it must be valued as ['automatic']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.client_registration_types_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"subset_of\": {\"type\": \"array\",\"const\": [\"automatic\"]},  \"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"subset_of\",  \"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_authentication_methods_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_authentication_methods_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_authentication_methods_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_authentication_methods_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_authentication_methods_supported parameter inside the openid_provider type is checked. It must contain value=true AND {\"essential\":true}.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_authentication_methods_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"value\": {\"type\": \"boolean\",\"const\": true},  \"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"value\",  \"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_authentication_signing_alg_values_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the request_authentication_signing_alg_values_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.request_authentication_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_authentication_signing_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the request_authentication_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain superset_of=[\"RS256\", \"RS512\"], subset_of=[\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.request_authentication_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\",\"RS512\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\",\"RS512\", \"ES256\", \"ES512\", \"PS256\",\"PS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain not valid values for the request_authentication_signing_alg_values_supported parameter",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the request_authentication_signing_alg_values_supported parameter inside the openid_provider type is checked. Must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.request_authentication_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"not\": {\"contains\": {\"enum\": [\"none\",\"HS256\",\"HS384\",\"HS512\"]}}},\"subset_of\": {\"not\": {\"contains\": {\"enum\": [\"none\",\"HS256\",\"HS384\",\"HS512\"]}}}},\"required\": [\"superset_of\",\"subset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_object_signing_alg_values_supported parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_object_signing_alg_values_supported parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.request_object_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_object_signing_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_object_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain superset_of=[\"RS256\", \"RS512\"], subset_of=[\"RS256\", \"RS512\", \"ES256\", \"ES512\", \"PS256\", \"PS512\"] AND {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.request_object_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\",\"RS512\"]}},\"subset_of\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"RS256\",\"RS512\", \"ES256\", \"ES512\", \"PS256\",\"PS512\"]}},\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"superset_of\",\"subset_of\",\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_object_signing_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_object_signing_alg_values_supported parameter inside the openid_provider type is checked. It must not contain the values ['none', 'HS256', 'HS384', 'HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.request_object_signing_alg_values_supported",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"superset_of\": {\"not\": {\"contains\": {\"enum\": [\"none\",\"HS256\",\"HS384\",\"HS512\"]}}},\"subset_of\": {\"not\": {\"contains\": {\"enum\": [\"none\",\"HS256\",\"HS384\",\"HS512\"]}}}},\"required\": [\"superset_of\",\"subset_of\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct issuer parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the issuer parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.issuer",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct issuer parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the issuer parameter inside the openid_provider type is checked. It must contain {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.issuer",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct authorization_endpoint parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the authorization_endpoint parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.authorization_endpoint",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct authorization_endpoint parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the authorization_endpoint parameter inside the openid_provider type is checked. It must contain  {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.authorization_endpoint",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct token_endpoint parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the token_endpoint parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.token_endpoint",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct token_endpoint parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the token_endpoint parameter inside the openid_provider type is checked. It must contain  {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.token_endpoint",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_endpoint parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the userinfo_endpoint parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_endpoint",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_endpoint parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the userinfo_endpoint parameter inside the openid_provider type is checked. It must contain  {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_endpoint",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct introspection_endpoint parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the introspection_endpoint parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.introspection_endpoint",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct introspection_endpoint parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the introspection_endpoint parameter inside the openid_provider type is checked. It must contain  {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.introspection_endpoint",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct revocation_endpoint parameter type",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the revocation_endpoint parameter inside the openid_provider type is checked. It must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.revocation_endpoint",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct revocation_endpoint parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the entity's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the revocation_endpoint parameter inside the openid_provider type is checked. It must contain  {\"essential\":true}",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.revocation_endpoint",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"essential\": {\"type\": \"boolean\",\"const\": true}},\"required\": [\"essential\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iss claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iss",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the sub claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "sub",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the iat claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "iat",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the logo_uri claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "logo_uri",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "exp",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "ref",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id_code claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "id_code",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "email",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_name",
                        "is present": "true"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration of a considered entity return a Federation Metadata in JOSE format when an HTTP GET request is made to its .well-known/openid-federation endpoint",
        "description": "The considered entity must have published its entity configuration in the .well-known/openid-federation endpoint. So in this test, an HTTP GET request is made to the entity's .well-known/openid-federation endpoint (appended to the URL which identifies the entity) and the response is analyzed. This response has to be the entity configuration of the entity and therefore a Federation Metadata in JOSE format (Content-Type: application/entity-statement+jwt)",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "checks": [
              {
                "in": "body",
                "check regex": "([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the resolve entity statement endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request containing the parameters 'sub', 'anchor' and 'type' is made to the entity's endpoint and an HTTP 200 OK response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Resolve Entity Statement response",
            "checks": [
              {
                "in": "body",
                "check regex": "[\\s*\"[^\"]*\"(?:,\\s*\"[^\"]*\")*\\s*\\]$",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP insert the correct type of client ID in the url of the request",
        "description": "In this test the Authentication Request is taken and the presence of the client_id parameter in the URL is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "checks": [
              {
                "in": "url",
                "check regex": "(?<=client_id=)https:\\/\\/.*?(?=&)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP correctly signed the JWT request",
        "description": "In this test the Authentication Request is taken and the presence of the request parameter in the URL is checked. It must be signed.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "checks": [
              {
                "in": "url",
                "check regex": "(?<=request=)[A-Za-z0-9-_=]+\\.[A-Za-z0-9-_=]+\\.?[A-Za-z0-9-_.+\\/=]*",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token request is sent",
        "description": "The token request sent by the RP must be sent",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "head",
                "check regex": "/token",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token request use HTTP POST",
        "description": "The token request sent by the RP must be sent in HTTP POST",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "head",
                "check regex": "POST",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the client_assertion in the token request contain a JWT",
        "description": "The client_assertion parameter in the token request sent by the RP must be a JWT",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "body",
                "check regex": "client_assertion=([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)(?:&|$)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP contain a valid Access Token in the UserInfo request",
        "description": "The UserInfo request from the RP is taken and analyzed. In the Authorization field of the head there must be a valid Access Token",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo request",
            "checks": [
              {
                "in": "head",
                "check regex": "Authorization:\\s?Bearer\\s?([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Request contain the client_assertion as a valid JWT",
        "description": "The Introspection request made by the RP is taken and the value of the client_assertion parameter is a signed JWT structure",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "checks": [
              {
                "in": "body",
                "check regex": "client_assertion=([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Request contain correct type token",
        "description": "The Introspection request made by the RP is taken and the type of the token parameter is a JWT",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "checks": [
              {
                "in": "body",
                "check regex": "token=([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)(?:&|$)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Revocation Request contain correct type of client assertion",
        "description": "The Revocation request made by the RP is taken and the value of the client_assertion parameter is a signed JWT structure",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "checks": [
              {
                "in": "body",
                "check regex": "client_assertion=([\\w]+)\\.([\\w]+)\\.([\\w\\-]*)(?:&|$)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Revocation Request contain correct type of client_id of the RP making the request",
        "description": "The Revocation request made by the RP is taken and the value of the client_id parameter is an HTTPS URL that identifies the RP",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "checks": [
              {
                "in": "body",
                "check regex": "(?<=client_id=)(https[^&]+)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Revocation Request contain correct type of token for which the request is made",
        "description": "The Revocation request made by the RP is taken and the value of the token parameter is a JWT.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "checks": [
              {
                "in": "body",
                "check regex": "token=([\\w=]+)\\.([\\w=]+)\\.([\\w\\-\\+\\/=]*)(?:&|$)",
                "is present": true
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP use an asymmetric algorithm to sign the JWT in the request parameter of the Authentication Request",
        "description": "In this test the Authentication Request is taken and the alg parameter in the JWT Header is checked. If it corresponds to a symmetric algorithm or it is none, than the RP is not compliant with the specifications.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.alg",
                    "is not in": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct value for organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the organization_type claim can be 'public' or 'private'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "organization_type",
                        "is in": [
                          "public",
                          "private"
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain incorrect 'id_token_encrypted_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'id_token_encrypted_response_alg' parameter is checked. It must not contain the value ['RSA_1_5'].",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.id_token_encrypted_response_alg",
                    "not contains": [
                      "RSA_1_5"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the organization_name claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the organization_name claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.organization_name",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the homepage_uri claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the homepage_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.homepage_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the policy_uri claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the policy_uri claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.policy_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the contacts claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the contacts claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.contacts",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the federation_resolve_endpoint claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the federation_resolve_endpoint claim in the 'federation_entity' entity type is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity.federation_resolve_endpoint",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'redirect_uris' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'redirect_uris' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.redirect_uris",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'grant_types' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'grant_types' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.grant_types",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'jwks' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'jwks' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'signed_jwks_uri' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'signed_jwks_uri' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.signed_jwks_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'id_token_signed_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'id_token_signed_response_alg' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.id_token_signed_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'id_token_encrypted_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'id_token_encrypted_response_alg' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.id_token_encrypted_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'userinfo_signed_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'userinfo_signed_response_alg' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.userinfo_signed_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'userinfo_encrypted_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'userinfo_encrypted_response_alg' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.userinfo_encrypted_response_alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'userinfo_encrypted_response_enc' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'userinfo_encrypted_response_enc' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.userinfo_encrypted_response_enc",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'token_endpoint_auth_method' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'token_endpoint_auth_method' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.token_endpoint_auth_method",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'client_id' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'client_id' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.client_id",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'client_registration_types' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'client_registration_types' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.client_registration_types",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'response_types' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'response_types' parameter in the 'openid_relying_party' metadata type is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.response_types",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the iss parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the sub parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the sub parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the iat parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the exp parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the jwks parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the jwks parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jwks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the metadata parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the metadata parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's entity configuration contain the authority_hints parameter",
        "description": "To accomplish this test, the Entity configuration of the OP is taken, the payload is decoded (Base64 encoding) and the presence of the authority_hints parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.authority_hints",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain the trust_marks parameter",
        "description": "To accomplish this test, the Entity configuration is taken, the payload is decoded (Base64 encoding) and the presence of the trust_marks parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.trust_marks",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP contain a correct JWT alg value",
        "description": "In this test the Authentication Request is taken and the presence of the alg parameter in the request_url is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.alg",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the JWT header of the Authentication Request contain the kid parameter",
        "description": "In this test the request parameter of the Authentication Request is taken, and the presence of the 'kid' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.kid",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP insert the client ID in the url of the request",
        "description": "In this test the Authentication Request is taken and the presence of the client_id parameter in the URL is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.client_id",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP insert the client ID in the url of the request",
        "description": "In this test the Authentication Request is taken and the presence of the code_challenge parameter in the URL is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.code_challenge",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP insert the client ID in the url of the request",
        "description": "In this test the Authentication Request is taken and the presence of the code_challenge_method parameter in the URL is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.code_challenge_method",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'nonce' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'nonce' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.nonce",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'prompt' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'prompt' parameter is checked. If it is missing, than the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.prompt",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'redirect_uri' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'redirect_uri' parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.redirect_uri",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'response_type' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'response_type' parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.response_type",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request contain the 'scope' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'scope' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.scope",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'acr_values' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'acr_values' parameter is checked. If it is missing, than the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.acr_values",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request contain the 'claims' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'claims' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.claims",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'state' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'state' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.state",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'exp' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'exp' parameter is checked. If it is missing, than the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'iat' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'iat' parameter is checked. If it is missing, than the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'iss' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'iss' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'aud' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'aud' parameter is checked. If it missing, than the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.aud",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'ui_locales' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'ui_locales' parameter is checked. If it is missing, the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.ui_locales",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the JWT payload contain 'iss' claim",
        "description": "This test can be performed by taking the JWT present in the 'client_assertion' field of the RP's request, base64url decoding the payload and checking if the iss claim is present.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the signed JWT assertion contain the sub claim",
        "description": "This test can be performed by taking the JWT present in the 'client_assertion' field of the RP's request, base64url decoding the payload and checking if the sub claim is present.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the signed JWT assertion contain the aud claim",
        "description": "This test can be performed by taking the JWT present in the 'client_assertion' field of the RP's request, base64url decoding the payload and checking if the aud claim is present.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.aud",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the signed JWT assertion contain the iat claim",
        "description": "This test can be performed by taking the JWT present in the 'client_assertion' field of the RP's request, base64url decoding the payload and checking if the iat claim is present.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iat",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the signed JWT assertion contain the exp claim",
        "description": "This test can be performed by taking the JWT present in the 'client_assertion' field of the RP's request, base64url decoding the payload and checking if the exp claim is present",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.exp",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the signed JWT assertion contain the jti claim",
        "description": "This test can be performed by taking the JWT present in the 'client_assertion' field of the RP's request, base64url decoding the payload and checking if the jti claim is present.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.jti",
                    "is present": "true"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity correctly sign the Entity Configuration",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken and the three parts of the JWT (header, payload and signature) are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter that must be taken from the Entity Statement of a superior), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier configured for the algorithm described in the Entity Configuration Header",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "jwt check sig": "X_key_RP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP correctly signed the JWT request",
        "description": "In this test the Authentication Request is taken and the presence of the request parameter in the URL is checked. It must be signed.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode regex": "(?<=request=)[A-Za-z0-9-_=]+\\.[A-Za-z0-9-_=]+\\.?[A-Za-z0-9-_.+\\/=]*",
                "type": "jwt",
                "jwt check sig": "X_key_core_RP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the client_assertion in the token request have a correct signature",
        "description": "The client_assertion parameter in the token request sent by the RP must be a JWT with a signature",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "jwt check sig": "X_key_core_RP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Request contain the client_assertion as a valid JWT",
        "description": "The Introspection request made by the RP is taken and the value of the client_assertion parameter is a signed JWT structure",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "(?<=client_assertion=)[^ ]+?(?=\\s|&|$)",
                "type": "jwt",
                "jwt check sig": "X_key_core_RP"
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain incorrect 'id_token_signed_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'id_token_signed_response_alg' parameter is checked. It must not contain the values ['none', 'HS256', 'HS384', 'HS512'].",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.id_token_signed_response_alg",
                    "is not in": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain incorrect 'userinfo_signed_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'userinfo_signed_response_alg' parameter is checked. It must not contain the values ['none', 'HS256', 'HS384', 'HS512'].",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.userinfo_signed_response_alg",
                    "is not in": [
                      "none",
                      "HS256",
                      "HS384",
                      "HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain incorrect 'userinfo_encrypted_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'userinfo_encrypted_response_alg' parameter is checked. It must not contain the value ['RSA_1_5'].",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.userinfo_encrypted_response_alg",
                    "is not in": [
                      "RSA_1_5"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain a correctly signed trust_marks",
        "description": "To accomplish this test, the Entity configuration is taken. The three parts of the JWT (header, payload and signature) composing the trust marks are base64url decoded. Finally, the signature is validated passing the public key (n, e of jwks parameter), the JWS Signature (received signature base64url decoded) and the JWS signing input (header and payload base64url encoded and concatenated with a dot dividing them) to a signature verifier.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "jwt check sig": "X_key_RP"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the /.well-known/openid-federation endpoint",
        "description": "In order to check the presence and correctness of the /.well-known/openid-federation endpoint, an HTTP GET request to the entity's endpoint is done and its entity configuration is expected as response.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct HTTP code in the EC response",
        "description": "In this test a correct request to the entity's /.well-known/openid-federation endpoint is made and the response is analyzed. It must be an HTTP 200 OK response",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "checks": [
              {
                "in": "head",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Entity expose the resolve entity statement endpoint",
        "description": "In order to check the presence and correctness of the resolve entity statement endpoint, an HTTP GET request containing the parameters 'sub', 'anchor' and 'type' is made to the entity's endpoint and an HTTP 200 OK response containing the resolved metadata for the entity in the request's sub claim is expected.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Resolve Entity Statement response",
            "checks": [
              {
                "in": "body",
                "check regex": "HTTP/?\\d?\\.?\\d?\\s200",
                "is present": "true"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct iss claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the iss claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain a correct sub claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the sub claim in it is checked. Its value has to be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the id claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the id claim in it is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"id\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct iat type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the iat claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"iat\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"iat\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correct type of logo_uri claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the logo_uri claim is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"logo_uri\": {\"type\": \"string\", \"format\": \"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"logo_uri\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the exp type",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the exp claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"exp\": { \"type\": \"integer\", \"minimum\": 0 } }, \"required\": [\"exp\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\"} }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain an URL in the ref claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the ref claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type\": \"object\", \"properties\": { \"ref\": { \"type\": \"string\", \"format\": \"uri\", \"pattern\":\"^http://\" } }, \"required\": [\"ref\"] }"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the organization_type claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the presence of the organization_type claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"organization_type\": {\"type\": \"string\"}}, \"required\": [\"organization_type\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain correcty type of id_code claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the value of the id_code claim must be a JSON Object",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"object\"}}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain the ipa_code claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the presence of the id_code claim contains at least the value 'ipa_code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": { \"id_code\": { \"type\": \"object\", \"properties\": {\"ipa_code\": {}},\"required\": [\"ipa_code\"]}},\"required\": [\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA for public organization contain a correct type of 'ipa_code' claim",
        "description": "In this test, a Trust Mark issued for a public entity must be taken, decrypted and the type of the value of the 'ipa_code' in the id_code claim is checked. It has to be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"ipa_code\": { \"type\":\"string\"}},\"required\":[\"ipa_code\"]}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the aoo_code claim",
        "description": "In this test, a Trust Mark issued by a SA must be taken, decrypted and verify the presence of the aoo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"aoo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued by an SA contain the uo_code claim",
        "description": "In this test, a Trust Mark issued by an SA must be taken, decrypted and verify the presence of the uo_code claim in the id_code",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\", \"properties\": {\"id_code\": {\"type\":\"object\", \"properties\": {\"uo_code\": { \"type\":\"string\"}}}},\"required\":[\"id_code\"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {\"type\":\"string\"},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response TA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the id_code claim of a Trust Mark issued for private organization contain the fiscal_number or vat_number claim",
        "description": "In this test, a Trust Mark issued for a private entity must be taken, decrypted and the presence of the fiscal_number or vat_number claim in the id_code is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks[0].trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{\"type\": \"object\",\"properties\": {\"id_code\": {\"type\": \"object\",\"properties\": {\"vat_number\": {},\"fiscal_number\": {\"type\":\"string\"}}}},\"if\": {\"properties\": {\"organization_type\": {\"const\": \"private\"}}},\"then\": {\"properties\": {\"id_code\": {\"anyOf\": [{\"required\": [\"vat_number\"]},{\"required\": [\"fiscal_number\"]}]}}}}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \"} },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of email claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the email claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{  \"type \":  \"object \",  \"properties \": {  \"email \": {  \"type \":  \"string \",  \"format \":  \"email \" } },  \"required \": [ \"email \"] } "
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Trust Mark contain the correct type of organization_name claim",
        "description": "In this test, an issued Trust Mark must be taken, decrypted and the type of the organization_name claim in it is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "type": "jwt",
                "decode regex": "[^\\r\\n]*",
                "decode operations": [
                  {
                    "from": "jwt payload",
                    "type": "jwt",
                    "decode param": "$.trust_marks.trust_mark",
                    "checks": [
                      {
                        "in": "payload",
                        "check": "$",
                        "json schema compliant": "{ \"type \": \u00a0\"object \", \"properties \": { \"organization_name \": { \"type \": \u00a0\"string \"}}, \"required \": [ \"organization_name \"]}"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token request contain a correct grant_type parameter",
        "description": "The grant_type parameter in the BODY of the token request sent by the RP must be set to authorization_code or to refresh_token. So in this test a token request is taken and the grant_type parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "body",
                "check regex": "(?<=grant_type=)([^&]+)",
                "is in": [
                  "authorization_code",
                  "refresh_token"
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP insert the correct value of client ID in the url of the request",
        "description": "In this test the Authentication Request is taken and the presence of the client_id parameter in the URL is checked. It must Uniquely identifies RP",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "checks": [
              {
                "in": "url",
                "check": "client_id",
                "is": "X_url_RP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP insert the correct value of client ID in the url of the request",
        "description": "In this test the Authentication Request is taken and the presence of the response_type parameter in the URL is checked. It must Uniquely identifies RP",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "checks": [
              {
                "in": "url",
                "check": "response_type",
                "is": "code"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token request use application/x-form-urlencoded",
        "description": "The token request sent by the RP must be sent using application/x-form-urlencoded",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "head",
                "check": "Content-Type",
                "is": "application/x-form-urlencoded"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the client_id in the token request identifies the RP",
        "description": "The client_id parameter in the BODY of the token request is taken. This parameter must identify the RP",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "body",
                "check": "client_id",
                "is": "X_https_RP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the client_assertion_type parameter in the token request contain the correct type",
        "description": "The client_assertion_type parameter in the BODY of the token request sent by the RP must be set to urn:ietf:params:oauth:client-assertion-type:jwtbearer",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "body",
                "check": "client_assertion_type",
                "is": "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Request contain correct type of client_assertion_type",
        "description": "The Introspection request made by the RP is taken and the value of the client_assertion_type parameter is urn:ietf:params:oauth:clientassertion-type:jwt-bearer",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "checks": [
              {
                "in": "body",
                "check": "client_assertion_type",
                "is": "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Request contain correct client id of the RP making the request",
        "description": "The Introspection request made by the RP is taken and the value of the client_id parameter identifies the RP",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "checks": [
              {
                "in": "body",
                "check": "client_id",
                "is": "X_url_RP"
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Revocation Request contain correct client_assertion_type",
        "description": "The Revocation request made by the RP is taken and the value of the client_assertion_type parameter is urn:ietf:params:oauth:clientassertion-type:jwt-bearer",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "checks": [
              {
                "in": "body",
                "check": "client_assertion_type",
                "is": "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Revocation Request contain correct type of client_id of the RP making the request",
        "description": "The Revocation request made by the RP is taken and the value of the client_id parameter is an URI that identifies the RP",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "checks": [
              {
                "in": "body",
                "check": "client_id",
                "is": "X_url_RP"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity return a correct Content-Type in the EC response",
        "description": "In this test a correct request to the entity's /.well-known/openid-federation endpoint is made and the response is analyzed. It must have a Content-Type parameter set to application/entity-statement+jwt",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "checks": [
              {
                "in": "head",
                "url decode": false,
                "is": "application/entity-statement+jwt",
                "check param": "Content-Type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP contain a correct JWT alg value",
        "description": "In this test the Authentication Request is taken and the presence of the alg parameter in the request_url is checked. It must be between [ RS256, RS512, ES256, ES512, PS256, PS512].",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$.alg",
                    "is in": [
                      "RS256",
                      "RS512",
                      "ES256",
                      "ES512",
                      "PS256",
                      "PS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'prompt' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the 'prompt' parameter is checked. It must be set to the value 'consent' or 'consent login'. If it contains other values or it is missing, than the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.prompt",
                    "is in": [
                      "consent",
                      "consent login"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request contain a correct value in 'scope' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the value of the 'scope' parameter must be set to the value 'openid' then it can (optionally) have the values 'offline_access', 'profile' or 'email' appended.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.scope",
                    "is in": [
                      "openid",
                      "openid profile",
                      "openid email",
                      "openid offline_access",
                      "openid offline_access profile",
                      "openid offline_access email",
                      "openid offline_access profile email",
                      "openid profile email"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'openid_relying_party'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "openid_relying_party.*(\\n.*)+\"openid_relying_party\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'openid_provider'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "openid_provider.*(\\n.*)+\"openid_provider\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'federation_entity'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "federation_entity.*(\\n.*)+\"federation_entity\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one 'oauth_authorization_server'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "oauth_authorization_server.*(\\n.*)+\"oauth_authorization_server\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only one  'oauth_resource'",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types cannot be repeated and must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "not matches regex": "oauth_resource.*(\\n.*)+\"oauth_resource\""
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct iss parameter value",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked. It must identify the issuing entity.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.iss",
                    "is": "X_url_RP"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration OP contain a correct sub parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the sub parameter is checked. Its value must be equal to the one in the iss parameter",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.sub",
                    "is": "X_url_RP"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct value of 'client_id' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'client_id' parameter that uniquely identifies the RP",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.client_id",
                    "is": "x_https_RP"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct 'id_token_signed_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'id_token_signed_response_alg' parameter is ['RS256', 'RS512', 'ES256', 'ES512', 'PS256', 'PS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.id_token_signed_response_alg",
                    "is in": [
                      "RS256",
                      "RS512",
                      "ES256",
                      "ES512",
                      "PS256",
                      "PS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct 'id_token_encrypted_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'id_token_encrypted_response_alg' parameter is ['RSA-OAEP', 'RSA-OAEP-256', 'ECDH-ES', 'ECDH-ES+A128KW', 'ECDH-ES+A256KW']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.id_token_encrypted_response_alg",
                    "is in": [
                      "RSA-OAEP",
                      "RSA-OAEP-256",
                      "ECDH-ES",
                      "ECDH-ES+A128KW",
                      "ECDH-ES+A256KW"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct 'id_token_encrypted_response_enc' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'id_token_encrypted_response_enc' parameter is ['A128CBC-HS256', 'A256CBC-HS512'].",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.id_token_encrypted_response_enc",
                    "is in": [
                      "A128CBC-HS256",
                      "A256CBC-HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct 'userinfo_signed_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'userinfo_signed_response_alg' parameter is ['RS256', 'RS512', 'ES256', 'ES512', 'PS256', 'PS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.userinfo_signed_response_alg",
                    "is in": [
                      "RS256",
                      "RS512",
                      "ES256",
                      "ES512",
                      "PS256",
                      "PS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct 'userinfo_encrypted_response_alg' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'userinfo_encrypted_response_alg' parameter is ['RSA-OAEP', 'RSA-OAEP-256', 'ECDH-ES', 'ECDH-ES+A128KW', 'ECDH-ES+A256KW']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.userinfo_encrypted_response_alg",
                    "is in": [
                      "RSA-OAEP",
                      "RSA-OAEP-256",
                      "ECDH-ES",
                      "ECDH-ES+A128KW",
                      "ECDH-ES+A256KW"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct 'userinfo_encrypted_response_enc' parameter",
        "description": "In this test the RP metadata are taken and the presence of the 'userinfo_encrypted_response_enc' parameter is ['A128CBC-HS256', 'A256CBC-HS512'].",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.userinfo_encrypted_response_enc",
                    "is in": [
                      "A128CBC-HS256",
                      "A256CBC-HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct 'token_endpoint_auth_method' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'token_endpoint_auth_method' parameter is 'one_of': 'private_key_jwt'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.token_endpoint_auth_method",
                    "is in": [
                      "private_key_jwt"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct 'client_registration_types' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'client_registration_types' parameter is 'automatic'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.client_registration_types[0]",
                    "is in": [
                      "automatic"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain in the 'response_types' the value 'code'",
        "description": "In this test the RP metadata are taken and the 'response_types' parameter in the 'openid_relying_party' contains the value 'code'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode regex": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party.response_types[0]",
                    "is in": [
                      "code"
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP insert the client ID in the url of the request",
        "description": "In this test the Authentication Request is taken and the presence of the client_id parameter in the URL is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "checks": [
              {
                "in": "url",
                "is present": true,
                "check": "client_id"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP insert the response type in the url of the request",
        "description": "In this test the Authentication Request is taken and the presence of the response_type parameter in the URL is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "checks": [
              {
                "in": "url",
                "is present": true,
                "check": "response_type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP insert the response type in the url of the request",
        "description": "In this test the Authentication Request is taken and the presence of the scope parameter in the URL is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "checks": [
              {
                "in": "url",
                "is present": true,
                "check": "scope"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP's Authentication Request contain the 'code_challenge' parameter",
        "description": "The Authentication request is taken and the presence of the 'code_challenge' parameter is checked. If it is present, than the Authentication Request is using PKCE and is compliant with the specifications, otherwise it is not compliant.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "checks": [
              {
                "in": "url",
                "is present": true,
                "check": "code_challenge"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP's Authentication Request contain the 'code_challenge_method' parameter",
        "description": "The Authentication request is taken and the presence of the 'code_challenge_method' parameter is checked. If it is not present, then the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "checks": [
              {
                "in": "url",
                "is present": true,
                "check": "code_challenge_method"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP insert the response type in the url of the request",
        "description": "In this test the Authentication Request is taken and the presence of the request parameter in the URL is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "checks": [
              {
                "in": "url",
                "is present": true,
                "check": "request"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token request contain the client_id",
        "description": "The token request sent by the RP must contain client_id parameter in the BODY",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "client_id"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token request contain the client_assertion",
        "description": "The token request sent by the RP must contain client_assertion parameter in the BODY",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "client_assertion"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token request contain the client_assertion_type",
        "description": "The token request sent by the RP must contain client_assertion_type parameter in the BODY",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "client_assertion_type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token request contain the code parameter",
        "description": "The token request sent by the RP must contain code parameter in the BODY",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "code"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token request contain the code_verifier parameter",
        "description": "The token request sent by the RP must contain code_verifier parameter in the BODY",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "code_verifier"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the token request contain the grant_type parameter",
        "description": "The token request sent by the RP must contain grant_type parameter in the BODY",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "grant_type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP revoke the Token when the User logs out",
        "description": "In order to test if the RP really revokes an access token on logout, a classic authentication flow is computed and, once obtained the token and used, a logout is performed. After this, the requests made by the RP must be analyzed and there has to be a request to the OP's revocation endpoint for only the access token",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "token"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP contain the Access Token in the UserInfo request",
        "description": "The UserInfo request from the RP is taken and analyzed. In the Authorization field of the header there must be an Access Token",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "UserInfo request",
            "checks": [
              {
                "in": "head",
                "is present": true,
                "check param": "Authorization"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Request use HTTP POST",
        "description": "The Introspection request made by the RP use HTTP POST",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "checks": [
              {
                "in": "url",
                "is present": true,
                "check": "POST"
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Request contain the client_assertion",
        "description": "The Introspection request made by the RP is taken and the presence of the client_assertion parameter is checked.",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "client_assertion"
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Request contain the client_assertion_type",
        "description": "The Introspection request made by the RP is taken and the presence of the client_assertion_type parameter is checked.",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "client_assertion_type"
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Request contain the client id of the RP making the request",
        "description": "The Introspection request made by the RP is taken and the presence of the client_id parameter is checked.",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "client_id"
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Request contain the token",
        "description": "The Introspection request made by the RP is taken and the presence of the token parameter is checked.",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "token"
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Revocation Request contain the client assertion",
        "description": "The Revocation request made by the RP is taken and the presence of the client_assertion parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "client_assertion"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Revocation Request contain the client_assertion_type",
        "description": "The Revocation request made by the RP is taken and the presence of the client_assertion_type parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "client_assertion_type"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Revocation Request contain the client_id of the RP making the request",
        "description": "The Revocation request made by the RP is taken and the presence of the client_id parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "client_id"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Revocation Request contain the token for which the request is made",
        "description": "The Revocation request made by the RP is taken and the presence of the token parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Revocation request",
            "checks": [
              {
                "in": "body",
                "is present": true,
                "check regex": "token"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct iss parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct iss parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iss parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iss\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct sub parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the sub parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct sub parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the sub parameter is checked. It must be a Number.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"sub\": {\"type\": \"string\", \"format\": \"uri\", \"pattern\": \"^https://\"}}, \"required\": [\"sub\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain a correct iat parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the iat parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain a correct exp parameter",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the exp parameter is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct jwks parameter type",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the jwks parameter is checked. It must be JSON Object that contains keys, which is a JSON Array, which contains at least kty, which is a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does entity configuration contain the correct jwks parameter type for IT",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the presence of the jwks parameter is checked. It must contain at least KID.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}, \"kid\":{\"type\":\"string\"}},\"required\":[\"kty\", \"kid\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain a JSON Object",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"metadata\": {\"type\": \"object\"}}, \"required\": [\"metadata\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata parameter contain only allowed types",
        "description": "To accomplish this test, the Entity configuration of the interested entity is taken, the payload is decoded (Base64 encoding) and the metadata parameter is analyzed. This must be a JSON object with each key representing a type of metadata. These types must be a value among the following: 'openid_relying_party', 'openid_provider', 'federation_entity', 'oauth_authorization_server', 'oauth_resource'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "json schema compliant": "{\"type\": \"object\",\"anyOf\": [{\"required\": [\"openid_relying_party\"]},{\"required\": [\"openid_provider\"]},{\"required\": [\"federation_entity\"]},{\"required\": [\"oauth_authorization_server\"]},{\"required\": [\"oauth_resource\"]}],\"properties\": {\"openid_relying_party\":{\"type\":\"object\"},\"openid_provider\":{\"type\":\"object\"},\"federation_entity\":{\"type\":\"object\"},\"oauth_authorization_server\":{\"type\":\"object\"},\"oauth_resource\":{\"type\":\"object\"}}, \"additionalProperties\": false}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's entity configuration contain a correct authority_hints parameter",
        "description": "To accomplish this test, the Entity configuration of the OP is taken, the payload is decoded (Base64 encoding) and the authority_hints parameter is checked, it must be an array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"authority_hints\": {\"type\": \"array\", \"items\":{\"type\":\"string\"}}}, \"required\": [\"authority_hints\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the OP's entity configuration contain a correct authority_hints parameter",
        "description": "To accomplish this test, the Entity configuration of the OP is taken, the payload is decoded (Base64 encoding) and the authority_hints parameter is checked, it must be an array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"authority_hints\": {\"type\": \"array\", \"items\":{\"type\":\"uri\"}}}, \"required\": [\"authority_hints\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain a correct trust_marks parameter",
        "description": "To accomplish this test, the Entity configuration is taken, the payload is decoded (Base64 encoding) and the type of the trust_marks parameter is checked. It must be an array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"trust_marks\": {\"type\": \"object\", \"additionalProperties\": {\"type\": \"array\"}}}, \"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the entity configuration contain a correct trust_marks parameter value",
        "description": "To accomplish this test, the Entity configuration is taken, the payload is decoded (Base64 encoding) and the type of the trust_marks parameter is checked. It MUST contain id (string) AND trust_mark (JWT).",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"trust_marks\": {\"type\": \"array\",\"items\": {\"type\": \"object\",\"properties\": {\"id\": {\"type\": \"string\"},\"trust_mark\": {\"type\": \"string\",\"pattern\": \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_.+/=]*$\"}},\"required\": [\"id\",\"trust_mark\"],\"additionalProperties\": true}}},\"required\": [\"trust_marks\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct organization_name claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the organization_name claim in the 'federation_entity' entity type is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"organization_name\": {\"type\": \"string\"}},\"required\": [\"organization_name\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct homepage_uri claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the homepage_uri claim in the 'federation_entity' entity type is checked. It must be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"homepage_uri\": {\"type\": \"string\",\"format\": \"uri\"}},\"required\": [\"homepage_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct policy_uri claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the policy_uri claim in the 'federation_entity' entity type is checked. It must be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"policy_uri\": {\"type\": \"string\",\"format\": \"uri\"}},\"required\": [\"policy_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain correct type logo_uri claim",
        "description": "In this test the metadata in the TA Entity Configuration are taken and the value of the logo_uri claim in the 'federation_entity' entity type is a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"logo_uri\":{\"type\":\"string\"}},\"required\":[\"logo_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain a correct logo_uri claim",
        "description": "In this test the metadata in the TA Entity Configuration are taken and the value of the logo_uri claim in the 'federation_entity' entity type is an HTTPS URL with an .svg file",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"logo_uri\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://.*\\\\.svg$\"}},\"required\":[\"logo_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain correct type contacts claim",
        "description": "In this test the metadata in the Entity Configuration are taken and the value of the contacts claim in the 'federation_entity' entity type is a JSON Array of String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"contacts\":{\"type\":\"array\", \"items\":{\"type\":\"string\"}}},\"required\":[\"contacts\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct federation_resolve_endpoint claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the federation_resolve_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_resolve_endpoint\": {\"type\": \"string\",\"format\": \"uri\", \"pattern\": \"^https://[^#]+$\"}},\"required\": [\"federation_resolve_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the metadata contain the correct federation_resolve_endpoint claim type",
        "description": "In this test the metadata in the Entity Configuration are taken and the presence of the federation_resolve_endpoint claim in the 'federation_entity' entity type is checked. It MUST be an HTTPS URL that ends with /trust_mark_status.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.federation_entity",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_resolve_endpoint\": {\"type\": \"string\",\"format\": \"uri-refrence\", \"pattern\":\"^https://.*/resolve\"}},\"required\": [\"federation_resolve_endpoint\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain at least federation_entity and openid_relying_party",
        "description": "In this test the RP metadata in the RP Entity Configuration are taken and the presence of the federation_entity and openid_relying_party is checked",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"federation_entity\": {\"type\": \"object\"},\"openid_relying_party\": {\"type\": \"object\"}},\"required\": [\"federation_entity\",\"openid_relying_party\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain a correct 'redirect_uris' parameter type",
        "description": "In this test the RP metadata are taken and the type of the 'redirect_uris' parameter is checked. It must be a JSON Array of URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"redirect_uris\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"format\": \"uri\"}}},\"required\": [\"redirect_uris\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain a correct 'redirect_uris' parameter type",
        "description": "In this test the RP metadata are taken and the type of the 'redirect_uris' parameter is checked.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"redirect_uris\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"format\": \"uri-reference\",\"pattern\": \"^https://.*$\"}}},\"required\": [\"redirect_uris\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct type grant_types claim",
        "description": "In this test the RP metadata are taken and the 'grant_types' parameter is a JSON array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"grant_types\":{\"type\":\"array\"}}, \"requirement\":[\"grant_type\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct grant_types claim",
        "description": "In this test the RP metadata are taken and the value of the 'grant_types' parameter contains 'authorization_code' and 'refresh_token'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party",
                    "json schema compliant": "{\"type\": \"object\",\"properties\": {\"grant_types\": {\"type\": \"array\",\"items\": {\"type\": \"string\",\"enum\": [\"authorization_code\", \"refresh_token\"]}}},\"required\": [\"grant_types\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the correct jwks claim type",
        "description": "In this test the RP metadata in the RP Entity Configuration are taken and the presence of the jwks claim in the 'openid_relying_party' entity type is checked. It must be a JSON Object that contains keys, which is a JSON Array, which contains at least kty, which is a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata.openid_relying_party.jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kty\":{\"type\":\"string\"}},\"required\":[\"kty\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the correct jwks claim type",
        "description": "In this test the RP metadata in the RP Entity Configuration are taken and the presence of the jwks claim in the 'RPenid_provider' entity type is checked. It must be a JSON Object that contains keys, which is a JSON Array, which contains kid, which is a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata.openid_relying_party.jwks",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"keys\":{\"type\":\"array\",\"properties\":{\"kid\":{\"type\":\"string\"}},\"required\":[\"kid\"]}},\"required\":[\"keys\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain a correct type of signed_jwks_uri claim",
        "description": "In this test the RP metadata in the RP Entity Configuration are taken and the type of the signed_jwks_uri claim in the 'openid_relying_party' entity type is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\r\\n]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$metadata.openid_relying_party",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"signed_jwks_uri\": {\"type\": \"string\", \"format\":\"uri-reference\", \"pattern\": \"^https://\"}}, \"required\": [\"signed_jwks_uri\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct type id_token_signed_response_alg parameter",
        "description": "In this test the RP metadata are taken and the id_token_signed_response_alg parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"id_token_signed_response_alg\":{\"type\":\"array\"}},\"required\":[\"id_token_signed_response_alg\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct type id_token_encrypted_response_alg parameter",
        "description": "In this test the RP metadata are taken and the id_token_encrypted_response_alg parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"id_token_encrypted_response_alg\":{\"type\":\"array\"}},\"required\":[\"id_token_encrypted_response_alg\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct type id_token_encrypted_response_enc parameter",
        "description": "In this test the RP metadata are taken and the id_token_encrypted_response_enc parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"id_token_encrypted_response_enc\":{\"type\":\"array\"}},\"required\":[\"id_token_encrypted_response_enc\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct type userinfo_signed_response_alg parameter",
        "description": "In this test the RP metadata are taken and the userinfo_signed_response_alg parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"userinfo_signed_response_alg\":{\"type\":\"array\"}},\"required\":[\"userinfo_signed_response_alg\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct type userinfo_encrypted_response_alg parameter",
        "description": "In this test the RP metadata are taken and the userinfo_encrypted_response_alg parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"userinfo_encrypted_response_alg\":{\"type\":\"array\"}},\"required\":[\"userinfo_encrypted_response_alg\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct type userinfo_encrypted_response_enc parameter",
        "description": "In this test the RP metadata are taken and the userinfo_encrypted_response_enc parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"userinfo_encrypted_response_enc\":{\"type\":\"array\"}},\"required\":[\"userinfo_encrypted_response_enc\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct type token_endpoint_auth_method parameter",
        "description": "In this test the RP metadata are taken and the token_endpoint_auth_method parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"token_endpoint_auth_method\":{\"type\":\"array\"}},\"required\":[\"token_endpoint_auth_method\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct type of 'client_id' parameter",
        "description": "In this test the RP metadata are taken and the value of the 'client_id' parameter is an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"client_id\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://\"}},\"required\":[\"client_id\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain correct type client_registration_types parameter",
        "description": "In this test the RP metadata are taken and the client_registration_types parameter in the 'openid_provider' subclaim (metadata type) is checked to be a JSON Array of strings.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_provider",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"client_registration_types\":{\"type\":\"array\", \"items\":{\"type\":\"string\"}}},\"required\":[\"client_registration_types\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP metadata contain the 'response_types' parameter as a json",
        "description": "In this test the RP metadata are taken and the 'response_types' parameter in the 'openid_relying_party' is a JSON array",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Configuration response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[^\\n\\r]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata.openid_relying_party",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"response_types\": {\"type\": \"array\"}}, \"required\": [\"response_types\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP contain a correct JWT alg type",
        "description": "In this test the Authentication Request is taken and the presence of the alg parameter in the request_url is checked. It must be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\":{\"alg\": {\"type\": \"string\"}},\"required\": [\"alg\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP contain a correct JWT kid type",
        "description": "In this test the Authentication Request is taken and the presence of the kid parameter in the request_url is checked. It must be a string",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "header",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\":{\"kid\": {\"type\": \"string\"}},\"required\": [\"kid\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP insert the correct type of client ID in the url of the request",
        "description": "In this test the Authentication Request is taken and the presence of the client_id parameter in the URL is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\":{\"client_id\": {\"type\": \"string\", \"format\":\"uri\", \"pattern\":\"^https://\"}},\"required\": [\"client_id\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP insert the correct type of client ID in the url of the request",
        "description": "In this test the Authentication Request is taken and the presence of the code_challenge parameter in the URL is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\":{\"code_challenge\": {\"type\": \"string\"}},\"required\": [\"code_challenge\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP insert the correct type of client ID in the url of the request",
        "description": "In this test the Authentication Request is taken and the presence of the code_challenge_method parameter in the URL is checked. It must be a String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\":{\"code_challenge_method\": {\"type\": \"string\"}},\"required\": [\"code_challenge_method\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'nonce' parameter is a string",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the value of the 'nonce' parameter must be a string.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"nonce\": {\"type\": \"string\"}}, \"required\": [\"nonce\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'nonce' parameter longer than 32 characters",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the value of the 'nonce' parameter must be at least 32 alphanumeric characters long.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"nonce\": {\"type\": \"string\", \"pattern\": \"^[\\u0020-\\u007E]{32,}$\"}}, \"required\": [\"nonce\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the correct 'prompt' parameter type",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the value of the 'prompt' parameter must be a string.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"prompt\": {\"type\": \"string\"}}, \"required\": [\"prompt\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the correct 'redirect_uris' parameter type",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the value of the 'redirect_uris' parameter must be a URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"redirect_uris\": {\"type\": \"string\", \"format\":\"uri\"}}, \"required\": [\"redirect_uris\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the correct 'response_type' parameter type",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the value of the 'response_type' parameter must be a string.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"response_type\": {\"type\": \"string\"}}, \"required\": [\"response_type\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the correct 'scope' parameter type",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the value of the 'scope' parameter must be a string.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"scope\": {\"type\": \"string\"}}, \"required\": [\"scope\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the correct type of 'acr_values' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'acr_values' parameter is checked. If it is missing, than the RP is not compliant with the specifications. It should be a string separated by a space",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"acr\":{\"type\":\"string\",\"pattern\":\"^[^\\\\s]+([^\\\\s]+)*$\"}},\"required\": [\"acr\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain a correct 'acr_values' parameter",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the presence of the 'acr_values' parameter is checked. If it is present, than it must be a string with the requested 'acr' values, each of them separated by a single space. The supported values are 'https://www.spid.gov.it/SpidL1', 'https://www.spid.gov.it/SpidL2' and 'https://www.spid.gov.it/SpidL3'. If it contains other values or it is missing, than the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"acr_values\":{\"type\":\"string\",\"pattern\":\"^(https://www\\\\.spid\\\\.gov\\\\.it/SpidL1|https://www\\\\.spid\\\\.gov\\\\.it/SpidL2|https://www\\\\.spid\\\\.gov\\\\.it/SpidL3)(\\\\s(https://www\\\\.spid\\\\.gov\\\\.it/SpidL1|https://www\\\\.spid\\\\.gov\\\\.it/SpidL2|https://www\\\\.spid\\\\.gov\\\\.it/SpidL3))*$\"}}}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the correct 'claims' parameter type",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the value of the 'claims' parameter must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$claims",
                    "json schema compliant": "{\"type\": \"object\"}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the correct 'claims' parameter type",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the value of the 'claims' parameter must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$claims",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"scope\":{\"type\":\"string\"},\"claims\":{\"type\":\"object\",\"properties\":{\"userinfo\":{\"$ref\":\"#/definitions/commonProperties\"},\"id_token\":{\"$ref\":\"#/definitions/commonProperties\"}}, \"additionalProperties\": False}},\"definitions\":{\"commonProperties\":{\"type\":\"object\",\"properties\":{\"given_name\":{\"type\":[\"string\",\"null\"]},\"family_name\":{\"type\":[\"string\",\"null\"]},\"place_of_birth\":{\"type\":[\"object\",\"null\"],\"properties\":{\"locality\":{\"type\":[\"string\",\"null\"]},\"region\":{\"type\":[\"string\",\"null\"]}},\"required\":[\"locality\",\"region\"]},\"birthdate\":{\"type\":[\"string\",\"null\"]},\"gender\":{\"type\":[\"string\",\"null\"],\"enum\":[\"female\",\"male\",null]},\"https://attributes.eid.gov.it/fiscal_number\":{\"type\":[\"string\",\"null\"]},\"email\":{\"type\":[\"string\",\"null\"],\"format\":\"email\"},\"document_details\":{\"type\":[\"object\",\"null\"],\"properties\":{\"type\":{\"type\":[\"string\",\"null\"],\"enum\":[\"cartaIdentita\",\"passaporto\",\"patenteGuida\",\"patenteNautica\",\"librettoPensione\",\"patentinoImpTermici\",\"portoArmi\",\"tesseraRiconoscimento\",null]},\"document_number\":{\"type\":[\"string\",\"null\"]},\"issuer\":{\"type\":[\"object\",\"null\"],\"properties\":{\"name\":{\"type\":[\"string\",\"null\"]}},\"required\":[\"name\"]},\"date_of_issuance\":{\"type\":[\"string\",\"null\"],\"format\":\"date\",\"pattern\":\"^\\\\d{4}-\\\\d{2}-\\\\d{2}$\"},\"date_of_expiry\":{\"type\":[\"string\",\"null\"],\"format\":\"date\",\"pattern\":\"^\\\\d{4}-\\\\d{2}-\\\\d{2}$\"}},\"required\":[\"type\",\"document_number\",\"issuer\",\"date_of_issuance\",\"date_of_expiry\"]},\"phone_number\":{\"type\":[\"string\",\"null\"],\"pattern\":\"^[0-9]+$\"},\"address\":{\"type\":[\"object\",\"null\"],\"properties\":{\"street_address\":{\"type\":\"string\"},\"postal_code\":{\"type\":\"string\"},\"locality\":{\"type\":\"string\"},\"region\":{\"type\":\"string\"},\"country_code\":{\"type\":\"string\",\"pattern\":\"^[A-Z]{2}$\"}},\"required\":[\"street_address\",\"postal_code\",\"locality\",\"region\",\"country_code\"]}},\"patternProperties\":{\"^https?:\\\\/\\\\/.+\\\\/spid_code$\":{\"type\":[\"string\",\"null\"],\"pattern\":\"^[A-Z]{4}[A-Za-z0-9]{10}$\"},\"^https?:\\\\/\\\\/.+\\\\/company_name$\":{\"type\":[\"string\",\"null\"]},\"^https?:\\\\/\\\\/.+\\\\/registered_office$\":{\"type\":[\"object\",\"null\"],\"properties\":{\"formatted\":{\"type\":[\"string\",\"null\"]}},\"required\":[\"formatted\"]},\"^https?:\\\\/\\\\/.+\\\\/fiscal_number$\":{\"type\":[\"string\",\"null\"],\"pattern\":\"^TINT-[A-Za-z0-9]+$\"},\"^https?:\\\\/\\\\/.+\\\\/company_fiscal_number$\":{\"type\":[\"string\",\"null\"],\"pattern\":\"^TINT-[A-Za-z0-9]+$\"},\"^https?:\\\\/\\\\/.+\\\\/vat_number$\":{\"type\":[\"string\",\"null\"],\"pattern\":\"^VATIT-[0-9]+$\"},\"^https?:\\\\/\\\\/.+\\\\/e_delivery_service$\":{\"type\":[\"string\",\"null\"],\"format\":\"email\"},\"^https?:\\\\/\\\\/.+\\\\/eid_exp_date\":{\"type\":[\"string\",\"null\"],\"format\":\"date\",\"pattern\":\"^\\\\d{4}-\\\\d{2}-\\\\d{2}$\"}},\"additionalProperties\":false}}}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the correct 'claims' parameter type",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the value of the 'claims' parameter must be a JSON Object.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$claims",
                    "json schema compliant": "{\"type\":\"object\",\"properties\":{\"scope\":{\"type\":\"string\"},\"claims\":{\"type\":\"object\",\"properties\":{\"userinfo\":{\"$ref\":\"#/definitions/commonProperties\"},\"id_token\":{\"$ref\":\"#/definitions/commonProperties\"}}}},\"required\":[\"scope\",\"claims\"],\"if\":{\"properties\":{\"scope\":{\"pattern\":\"\\\\bprofile\\\\b\"}}},\"then\":{\"properties\":{\"claims\":{\"properties\":{\"userinfo\":{\"required\":[\"given_name\",\"family_name\",\"birthdate\",\"https://attributes.eid.gov.it/fiscal_number\"]},\"id_token\":{\"required\":[\"given_name\",\"family_name\",\"birthdate\",\"https://attributes.eid.gov.it/fiscal_number\"]}},\"required\":[\"userinfo\",\"id_token\"]}}},\"else\":{\"if\":{\"properties\":{\"scope\":{\"pattern\":\"\\\\bemail\\\\b\"}}},\"then\":{\"properties\":{\"claims\":{\"properties\":{\"userinfo\":{\"required\":[\"email\",\"email_verified\"]},\"id_token\":{\"required\":[\"email\",\"email_verified\"]}},\"required\":[\"userinfo\",\"id_token\"]}}},\"else\":{\"if\":{\"properties\":{\"scope\":{\"pattern\":\"\\\\bprofile\\\\b.*\\\\bemail\\\\b|\\\\bemail\\\\b.*\\\\bprofile\\\\b\"}}},\"then\":{\"properties\":{\"claims\":{\"properties\":{\"userinfo\":{\"required\":[\"given_name\",\"family_name\",\"birthdate\",\"https://attributes.eid.gov.it/fiscal_number\",\"email\",\"email_verified\"]},\"id_token\":{\"required\":[\"given_name\",\"family_name\",\"birthdate\",\"https://attributes.eid.gov.it/fiscal_number\",\"email\",\"email_verified\"]}},\"required\":[\"userinfo\",\"id_token\"]}}},\"else\":{\"properties\":{\"claims\":{\"properties\":{\"userinfo\":{\"required\":[]},\"id_token\":{\"required\":[]}}}}}}},\"definitions\":{\"commonProperties\":{\"type\":\"object\",\"properties\":{\"given_name\":{\"type\":[\"string\",\"null\"]},\"family_name\":{\"type\":[\"string\",\"null\"]},\"place_of_birth\":{\"type\":[\"object\",\"null\"],\"properties\":{\"locality\":{\"type\":[\"string\",\"null\"]},\"region\":{\"type\":[\"string\",\"null\"]}},\"required\":[\"locality\",\"region\"]},\"birthdate\":{\"type\":[\"string\",\"null\"]},\"gender\":{\"type\":[\"string\",\"null\"],\"enum\":[\"female\",\"male\",null]},\"https://attributes.eid.gov.it/fiscal_number\":{\"type\":[\"string\",\"null\"]},\"email\":{\"type\":[\"string\",\"null\"],\"format\":\"email\"},\"email_verified\":{\"type\":[\"boolean\",\"null\"]},\"document_details\":{\"type\":[\"object\",\"null\"],\"properties\":{\"type\":{\"type\":[\"string\",\"null\"],\"enum\":[\"cartaIdentita\",\"passaporto\",\"patenteGuida\",\"patenteNautica\",\"librettoPensione\",\"patentinoImpTermici\",\"portoArmi\",\"tesseraRiconoscimento\",null]},\"document_number\":{\"type\":[\"string\",\"null\"]},\"issuer\":{\"type\":[\"object\",\"null\"],\"properties\":{\"name\":{\"type\":[\"string\",\"null\"]}},\"required\":[\"name\"]},\"date_of_issuance\":{\"type\":[\"string\",\"null\"],\"format\":\"date\",\"pattern\":\"^\\\\d{4}-\\\\d{2}-\\\\d{2}$\"},\"date_of_expiry\":{\"type\":[\"string\",\"null\"],\"format\":\"date\",\"pattern\":\"^\\\\d{4}-\\\\d{2}-\\\\d{2}$\"}},\"required\":[\"type\",\"document_number\",\"issuer\",\"date_of_issuance\",\"date_of_expiry\"]},\"phone_number\":{\"type\":[\"string\",\"null\"],\"pattern\":\"^[0-9]+$\"},\"phone_number_verified\":{\"type\":[\"boolean\",\"null\"]},\"address\":{\"type\":[\"object\",\"null\"],\"properties\":{\"street_address\":{\"type\":\"string\"},\"postal_code\":{\"type\":\"string\"},\"locality\":{\"type\":\"string\"},\"region\":{\"type\":\"string\"},\"country_code\":{\"type\":\"string\",\"pattern\":\"^[A-Z]{2}$\"}},\"required\":[\"street_address\",\"postal_code\",\"locality\",\"region\",\"country_code\"]}},\"patternProperties\":{\"^https?:\\\\/\\\\/.+\\\\/fiscal_number$\":{\"type\":[\"string\",\"null\"],\"pattern\":\"^TINT-[A-Za-z0-9]+$\"},\"^https?:\\\\/\\\\/.+\\\\/landline_number$\":{\"type\":[\"string\",\"null\"],\"pattern\":\"^[0-9]+$\"},\"^https?:\\\\/\\\\/.+\\\\/e_delivery_service$\":{\"type\":[\"string\",\"null\"],\"format\":\"email\"}},\"additionalProperties\":false}}}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'state' parameter is a string",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the value of the 'state' parameter must be a string, then the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"state\": {\"type\": \"string\"}}, \"required\": [\"state\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'state' parameter greater than 32 characters",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the value of the 'state' parameter must be at least 32 alphanumeric characters long. If it is not present or its length is less than 32 alphanumeric characters, then the RP is not compliant with the specifications",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"state\": {\"type\": \"string\", \"pattern\": \"^[\\u0020-\\u007E]{32,}$\"}}, \"required\": [\"state\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'exp' parameter is a Number",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the value of the 'exp' parameter must be a Number",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP Authentication Request's JWT contain the 'iat' parameter is a Number",
        "description": "The Authentication request is taken, the JWT Token in the request parameter base64url decoded and the value of the 'iat' parameter must be a Number",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP insert the correct type of iss",
        "description": "In this test the Authentication Request is taken and the presence of the iss parameter in the URL is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\":{\"iss\": {\"type\": \"string\", \"format\":\"uri\", \"pattern\":\"^https://\"}},\"required\": [\"iss\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP insert the correct type of aud",
        "description": "In this test the Authentication Request is taken and the presence of the aud parameter in the URL is checked. It must be an HTTPS URL.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\":{\"aud\": {\"type\": \"string\", \"format\":\"uri\", \"pattern\":\"^https://\"}},\"required\": [\"aud\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP insert the correct type of ui_locales",
        "description": "In this test the Authentication Request is taken and the presence of the ui_locales parameter is checked. It must be a String.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\":{\"ui_locales\": {\"type\": \"string\"}},\"required\": [\"ui_locales\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the RP insert the correct type of ui_locales",
        "description": "In this test the Authentication Request is taken and the presence of the ui_locales parameter in the URL is checked. It must be a string compliant with RFC5646 code with spaces.",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Authentication request",
            "decode operations": [
              {
                "from": "url",
                "decode param": "request",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\",\"properties\":{\"ui_locales\": {\"type\": \"string\", \"pattern\":\"^([a-zA-Z]{2,3}(-[a-zA-Z]{4})?(-[a-zA-Z]{2})?)( ([a-zA-Z]{2,3}(-[a-zA-Z]{4})?(-[a-zA-Z]{2})?))*$\"}},\"required\": [\"ui_locales\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the signed JWT assertion contain a correct aud claim type",
        "description": "This test can be performed by taking the JWT present in the 'client_assertion' field of the RP's request, base64url decoding the payload and checking the aud. Its value must be an URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"aud\": {\"type\": \"array\", \"format\": \"uri-reference\"}}, \"required\": [\"aud\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the signed JWT assertion contain a correct iat claim",
        "description": "This test can be performed by taking the JWT present in the 'client_assertion' field of the RP's request, base64url decoding the payload and checking the iat claim. Its value must be a timestap",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"iat\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"iat\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the signed JWT assertion contain a correct exp claim",
        "description": "This test can be performed by taking the JWT present in the 'client_assertion' field of the RP's request, base64url decoding the payload and checking the exp claim. Its value must be a timestap",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=client_assertion=)([^&]+)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\": \"object\", \"properties\": {\"exp\": {\"type\": \"integer\", \"minimum\": 0}}, \"required\": [\"exp\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Request contain correct type of client id of the RP making the request",
        "description": "The Introspection request made by the RP is taken and the value of the client_id parameter is an URI",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=token=).*(?=&)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"client_id\":{\"type\":\"string\"}},\"required\":[\"client_id\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the Introspection Request contain correct type of client id of the RP making the request",
        "description": "The Introspection request made by the RP is taken and the value of the client_id parameter is an URI",
        "type": "passive",
        "sessions": [
          "s_CIE_introsp"
        ],
        "operations": [
          {
            "message type": "Introspection request",
            "decode operations": [
              {
                "from": "body",
                "decode param": "(?<=token=).*(?=&)",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$",
                    "json schema compliant": "{\"type\":\"object\", \"properties\":{\"client_id\":{\"type\":\"string\", \"format\":\"uri\"}},\"required\":[\"client_id\"]}"
                  }
                ]
              }
            ]
          }
        ],
        "result": "correct flow s_CIE_introsp"
      }
    },
    {
      "test": {
        "name": "Does the client_id in the token request contain a String",
        "description": "The client_id parameter in the BODY of the token request is taken and checked to be a String",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "body",
                "check": "$",
                "json schema compliant": "{\"type\":\"object\", \"properties\":{\"client_id\":{\"type\":\"string\"}},\"required\":[\"client_id\"]})"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    },
    {
      "test": {
        "name": "Does the client_id in the token request contain an HTTPS URL",
        "description": "The client_id parameter in the BODY of the token request is taken and checked to be an HTTPS URL",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Token request",
            "checks": [
              {
                "in": "body",
                "check": "$",
                "json schema compliant": "{\"type\":\"object\", \"properties\":{\"client_id\":{\"type\":\"string\", \"format\":\"uri\", \"pattern\":\"^https://\"}},\"required\":[\"client_id\"]})"
              }
            ]
          }
        ],
        "result": "correct flow s1"
      }
    }
  ]
}