{
  "test suite": {
    "name": "TA",
    "description": "JWT list parameter contains",
    "filter messages": true
  },
  "tests": [
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct acr_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the acr_values_supported parameter inside the openid_provider type is checked. It must contain the value 'subset_of': ['https://www.spid.gov.it/SpidL1', 'https://www.spid.gov.it/SpidL2', 'https://www.spid.gov.it/SpidL3']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.acr_values_supported.subset_of",
                    "is subset of": [
                      "https://www.spid.gov.it/SpidL1\",\"https://www.spid.gov.it/SpidL2",
                      "https://www.spid.gov.it/SpidL3"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct authorization_response_iss_parameter_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the authorization_response_iss_parameter_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of' and it must be valued as ['true']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.authorization_response_iss_parameter_supported.one_of",
                    "is subset of": [
                      "true"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct claims_parameter_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the claims_parameter_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of' and it must be valued as ['true']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.claims_parameter_supported.one_of",
                    "is subset of": [
                      "true"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct client_registration_types_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the client_registration_types_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of' and it must be valued as ['automatic']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.client_registration_types_supported.one_of",
                    "is subset of": [
                      "automatic"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct code_challenge_methods_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the code_challenge_methods_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' and it must be valued as ['S256']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.code_challenge_methods_supported.subset_of",
                    "is subset of": [
                      "S256"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct grant_types_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' and it must be valued as ['refresh_token', 'authorization_code']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.grant_types_supported.subset_of",
                    "is subset of": [
                      "refresh_token\",\"authorization_code"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_encryption_enc_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encryption_enc_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' and must be valued as ['A128CBC-HS256', 'A256CBC-HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encryption_enc_values_supported.subset_of",
                    "is subset of": [
                      "A128CBC-HS256\",\"A256CBC-HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct id_token_signing_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' and it must be valued as ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_signing_alg_values_supported.subset_of",
                    "is subset of": [
                      "RS256\",\"RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_authentication_methods_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_authentication_methods_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of' and it must be valued with ['request_object']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_authentication_methods_supported.one_of",
                    "is subset of": [
                      "request_object"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_authentication_signing_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the request_authentication_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' valued as ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.request_authentication_signing_alg_values_supported.subset_of",
                    "is subset of": [
                      "RS256\",\"RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct request_parameter_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the request_parameter_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of' valued with ['true']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.request_parameter_supported.one_of",
                    "is subset of": [
                      "true"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct response_modes_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_modes_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' and it is valued with['form_post', 'query']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.response_modes_supported.subset_of",
                    "is subset of": [
                      "form_post\",\"query"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct response_types_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the response_types_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of' valued with ['code']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.response_types_supported.one_of",
                    "is subset of": [
                      "code"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct revocation_endpoint_auth_methods_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the revocation_endpoint_auth_methods_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of' valued with ['private_key_jwt']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.revocation_endpoint_auth_methods_supported.one_of",
                    "is subset of": [
                      "private_key_jwt"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct scopes_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the scopes_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' valued with ['openid', 'offline_access', 'profile', 'email']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.scopes_supported.subset_of",
                    "is subset of": [
                      "openid\",\"offline_access\",\"profile\",\"email"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct subject_types_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the subject_types_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of' valued with ['pairwise']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.subject_types_supported.one_of",
                    "is subset of": [
                      "pairwise"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain the token_endpoint_auth_methods_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the token_endpoint_auth_methods_supported parameter inside the openid_provider type is checked. It must contain the key 'one_of' valued with ['private_key_jwt']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_provider.token_endpoint_auth_methods_supported.one_of",
                    "is subset of": [
                      "private_key_jwt"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct token_endpoint_auth_signing_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' valued with ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.token_endpoint_auth_signing_alg_values_supported.subset_of",
                    "is subset of": [
                      "RS256\",\"RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_encryption_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encryption_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' valued with ['RSA-OAEP', 'RSA-OAEP-256']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encryption_alg_values_supported.subset_of",
                    "is subset of": [
                      "RSA-OAEP\",\"RSA-OAEP-256"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_encryption_enc_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encryption_enc_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' valued with ['A128CBC-HS256', 'A256CBC-HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encryption_enc_values_supported.subset_of",
                    "is subset of": [
                      "A128CBC-HS256\",\"A256CBC-HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an OP contain a correct userinfo_signing_alg_values_supported parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an OP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signing_alg_values_supported parameter inside the openid_provider type is checked. It must contain the key 'subset_of' valued with ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response OP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_signing_alg_values_supported.subset_of",
                    "is subset of": [
                      "RS256\",\"RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct client_registration_types parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types parameter inside the openid_relying_party type is checked. It must contain the key 'one_of' valued with ['automatic']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.client_registration_types.one_of",
                    "is subset of": [
                      "automatic"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct grant_types parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of' valued with '[authorization_code, refresh_token]'",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.grant_types.subset_of",
                    "is subset of": [
                      "authorization_code\",\"refresh_token"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_encrypted_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of' valued with ['RSA-OAEP', 'RSA-OAEP-256']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_encrypted_response_alg.subset_of",
                    "is subset of": [
                      "RSA-OAEP\",\"RSA-OAEP-256"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_encrypted_response_enc parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_enc parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of' valued with ['A128CBC-HS256', 'A256CBC-HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_encrypted_response_enc.subset_of",
                    "is subset of": [
                      "A128CBC-HS256\",\"A256CBC-HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct id_token_signed_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of' valued with ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.id_token_signed_response_alg.subset_of",
                    "is subset of": [
                      "RS256\",\"RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct token_endpoint_auth_method parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_method parameter inside the openid_relying_party type is checked. It must contain the key 'one_of' valued with ['private_key']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.token_endpoint_auth_method.one_of",
                    "is subset of": [
                      "private_key"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct userinfo_encrypted_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of' valued with ['RSA-OAEP', 'RSA-OAEP-256']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_encrypted_response_alg.subset_of",
                    "is subset of": [
                      "RSA-OAEP\",\"RSA-OAEP-256"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain the userinfo_encrypted_response_enc parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_enc parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of' valued with ['A128CBC-HS256', 'A256CBC-HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_encrypted_response_enc.subset_of",
                    "is subset of": [
                      "A128CBC-HS256\" , \"A256CBC-HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an RP contain a correct userinfo_signed_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an RP must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter inside the openid_relying_party type is checked. It must contain the key 'subset_of' valued with ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response RP",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.openid_relying_party.userinfo_signed_response_alg.subset_of",
                    "is subset of": [
                      "RS256\",\"RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct client_registration_types parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the client_registration_types parameter inside the intermediary type is checked. It must contain the key 'one_of' valued with ['automatic']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.client_registration_types.one_of",
                    "is subset of": [
                      "automatic"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct grant_types parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the grant_types parameter inside the intermediary type is checked. It must contain the key 'subset_of' values with ['authorization_code', 'refresh_token']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.grant_types.subset_of",
                    "is subset of": [
                      "authorization_code\",\"refresh_toke"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_encrypted_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_alg parameter inside the intermediary type is checked. It must contain the key 'subset_of': valued with ['RSA-OAEP', 'RSA-OAEP-256']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encrypted_response_alg.subset_of",
                    "is subset of": [
                      "RSA-OAEP\",\"RSA-OAEP-256"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_encrypted_response_enc parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_encrypted_response_enc parameter inside the intermediary type is checked. It must contain the key 'subset_of' valued with ['A128CBC-HS256', 'A256CBC-HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_encrypted_response_enc.subset_of",
                    "is subset of": [
                      "A128CBC-HS256\",\"A256CBC-HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct id_token_signed_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the id_token_signed_response_alg parameter inside the intermediary type is checked. It must contain the key 'subset_of' valued with ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.id_token_signed_response_alg.subset_of",
                    "is subset of": [
                      "RS256\",\"RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct token_endpoint_auth_method parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the token_endpoint_auth_method parameter inside the intermediary type is checked. It must contain the key 'one_of' valued with ['private_key']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.token_endpoint_auth_method.one_of",
                    "is subset of": [
                      "private_key"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_encrypted_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_alg parameter inside the intermediary type is checked. It must contain the key 'subset_of' valued with ['RSA-OAEP', 'RSA-OAEP-256']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encrypted_response_alg.subset_of",
                    "is subset of": [
                      "RSA-OAEP\",\"RSA-OAEP-256"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_encrypted_response_enc parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_encrypted_response_enc parameter inside the intermediary type is checked. It must contain the key 'subset_of' valued with ['A128CBC-HS256', 'A256CBC-HS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_encrypted_response_enc.subset_of",
                    "is subset of": [
                      "A128CBC-HS256\",\"A256CBC-HS512"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "test": {
        "name": "Does the TA's metadata policy for an SA contain a correct userinfo_signed_response_alg parameter value",
        "description": "In order to check the compliance of a metadata policy issued by the TA, an entity statement for an SA must be fetched in the TA's fetch endpoint. Once obtained the entity statement, the metadata_policy parameter is taken and the presence of the userinfo_signed_response_alg parameter inside the intermediary type is checked. It must contain the key 'subset_of' valued with ['RS256', 'RS512']",
        "type": "passive",
        "sessions": [
          "s1"
        ],
        "operations": [
          {
            "message type": "Entity Statement response SA",
            "decode operations": [
              {
                "from": "body",
                "decode param": "[\\s\\S]*",
                "type": "jwt",
                "checks": [
                  {
                    "in": "payload",
                    "check": "$.metadata_policy.intermediary.userinfo_signed_response_alg.subset_of",
                    "is subset of": [
                      "RS256\",\"RS512"
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  ]
}