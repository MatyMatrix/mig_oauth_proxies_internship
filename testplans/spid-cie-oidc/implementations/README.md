# Testplan

This repository contains a *csv* file titled `testplancsv` that encompasses all tests in a human readable format, covering SPID/CIE OIDC. In order to make the dataset more comprehensible and user-friendly, we have included a clear explanation of each column:

- UID: distinctive value assigned to Uniquely Identify each record in the dataset, as `entity_under_test-message_under_test-caracteristic`. It is used as a name for each test.
- Input to test: describes the message or the token that must be analyzed and, if needed, its peculiarities.
- Input to Entity Under Test: information, parameters, or specific details serving as inputs for the testing process.
- Output: records the result, data or information expected by the execution of the test.
- [Pattern name](#Pattern-name): contains names categorizing different recognized structures. More details in the later section.
- Message Under test: the message of the protocol affected by the test.
- Test Name: contains a descriptive name of the test.
- Description: aims to explain how the test must be accomplished.
- Entity under test: the entity undergoing evaluation. It can be either Relying Party (RP), OpenID Provider (OP), Trust Anchor (TA), Federation Authority (SA), Attribute Authority (AA) or a mixture of them.
- Requirement: outlines the specific needs, criteria or conditions for a successful compliance. This field essentially describes the reason why the test is done. This field is useful for both understanding why a test is done and for being used as a starting point for the implementation of the tests that are not present in the sources already gathered.
- Requirement Source: specifies documents, standards, or guidelines used to define the requirement.
- Profile: specify the OIDC profile considered. It can be either OIDC Core or OIDC Federation.
- Reference OAuch: contains the references associated with [OAuch](https://oauch.io/Tests)
- Reference OpenID Connect Conformance Profiles v3.0: contains the references associated with [OpenID Connect Conformance Profiles v3.0](https://gitlab.com/openid/conformance-suite/-/tree/master/src/main/java/net/openid/conformance/openid)
- Notes: provides additional information, context or background to enhance the comprehension.
- Comments: contains textual annotations or remarks.

## Pattern name

This column assists in cataloging and distinguishing various recognized recurring structures or formats. It has been divided in [Correct Input](#correct-input) and [Wrong input](#wrong-input), depending on the expected result.

### Correct input

The "correct generation" type corresponds to tests where "the tester takes as input a message generated by the Entity Under Test (EUT) and checks whether a specific parameter is there and/or its value is correct". While writing the code for the automation, we figured out that those tests are equal in a conceptual point or view, but not in a strictly implementative point of view.

| Pattern name | What we have to do | Information needed by the test | Need by the Oracle |
| ---- | ---- | ---- | ---- |
| **HTTP list value** | Verify the value of a param*name* in the _message type_ is between a list of value | - | message type \| {head/body/url} \| param_name \| list_of_value
| **HTTP parameter presence_1** | Verify that the param*name* (i.e., Location) in the _message type_ conatins a value (i.e., code,state,iss) | - | message type \| {head/body/url} \| param_name | value
| **HTTP parameter presence** | Verify the presence in the _message type_ of a param*name* (i.e., code,state,iss) | - | message type \| {head/body/url} \| param_name
| **HTTP parameter type** | Verify the *type* (with a regex) of a param*name* (i.e., code,state,iss) in the *message type* | - | message type \| {head/body/url} \| param_name.type |
| **HTTP parameter value_1** | Verify that the paramvalue of a param*name* in the _message type_ is equal to an _url_encoded_ *value* | - | message type \| {head/body/url} \| param_name \| value |
| **HTTP parameter value** | Verify that the paramvalue of a param*name* in the _message type_ is equal to a *value* | - | message type \| {head/body/url} \| param_name \| value |
| **HTTP Status** | Verify in the _message type_ the *HTTP status* | - | message type \| {head/body/url} \| HTTP_status |
| **JSON in JWT parameter type** | Verify the *type* (regex) of a param*name* located in a param*path* (path separated by dots) in the JSON, in *header/payload* of a decoded JWT (jwt_name) in the *message type* | - | message type \| {head/body/url} \| jwt_name \| {header/payload} \| param_path \| type
| **JWE list values** | Verify the value of a param*name* located in a decoded JWE is between a list (at least one present). Select the _message type_, *JWE_name* interested (all the JWE with [\s\S]*) and then the param | - | message type \| {head/body/url} \| JWE_name \| {header/payload} \| param_name \| list_of_value |
| **JWE parameter not in value** | Verify the value is not between a list (all) of a param*name* located in a decoded JWE | - | message type \| {head/body/url} \| JWE_name \| {header/payload} \| param_name \| list_of_value
| **JWE parameter presence** | Verify the presence of a param*name* located in a decoded JWE | - | message type \| {head/body/url} \| JWE_name \| {header/payload} \| param_name
| **JWE parameter values** | Verify the *value* of a param*name* located in a decoded JWE | - | message type \| {head/body/url} \| JWE_name \| {header/payload} \| param_name \| value
| **JWT Check-Save to JWT_same message** | Send a _message type_ and save the value of a param*name* in a JWT_name. Then verify in the same *message type* that a jwt_param_name in the JWT (that is located at jwt_name) has values that are inside the param_name_value saved before | message type \| {head/body/url} \| jwt_name \| {header/payload} \| param_path \| saved_param | message type \| {head/body/url} \| jwt_name \| {header/payload} \| jwt_param_name |
| **JWT Check-Save to JWT** | Send a _message type_ and save the value of a param*name* in a JWT_name. Then verify in the second *message type* that a jwt_param_name in the JWT (that is located at jwt_name) has values that are inside the param_name_value saved before | message type \| {head/body/url} \| jwt_name \| {header/payload} \| param_path \| saved_param | message type \| {head/body/url} \| jwt_name \| {header/payload} \| jwt_param_name |
| **JWT list parameter contains** | Verify that the list present in the param*value* of a param*path* located in header/payload of a decoded JWT (jwt_name) in the *message type* contains certain values | - | message type \| {head/body/url} \| jwt_name \| {header/payload} \| param_path \| ["param_value1", "param_value2", ...] |
| **JWT list parameter does not contain** | Verify that the list present in the param*value* of a param*path* located in header/payload of a decoded JWT (jwt_name) in the *message type* does not contain certain values | - | message type \| {head/body/url} \| jwt_name \| {header/payload} \| param_path \| ["param_value1", "param_value2", ...] |
| **JWT list value** | Verify the value of a param*name* located in header/payload of a decoded JWT (jwt_name) in the _message type_ is between a list of value | - | message type \| {head/body/url} \| jwt_name \| {header/payload} \| param_name \| list_of_value 
| **JWT parameter JSON presence** | Verify the presence of a param*path* located in header/payload of a decoded JWT (jwt_name) in the *message type*| - | message type\| {head/body/url} \| jwt_name \| {header/payload} \| param_path |
| **JWT parameter JSON value** | Verify the json*list_value* (at least one) of a json_param_path of a param_name in a JWT (located at jwt_name) in the *message type* | - | message type \| {head/body/url} \| jwt_name \| {header/payload} \| json_param_path \| json_list_value |
| **JWT parameter not in JSON value**     | Verify that the json*list_value* of a json_param_path in a JWT (located at jwt_name) in the *message type* is not a given value (all) | - | message type \| {head/body/url} \| jwt_name \| {header/payload} \| json_param_path \| ["json_param_value", "json_param_value1", ...] |
| **JWT parameter not in value** | Verify that the param*value* of a param_name located in header/payload of a decoded JWT (jwt_name) in the *message type* is not inside a range of values | - | message type \| {head/body/url} \| jwt_name \| {header/payload/signature} \| param_name \| ["json_param_value", "json_param_value1", ...] |
| **JWT parameter presence** | Verify the presence of a param*name* located in header/payload of a decoded JWT (jwt_name) in the *message type* | - | message type \| {head/body/url} \| jwt_name \| {header/payload} \| param_name |
| **JWT parameter type** | Verify the type (reges) in header/payload of a decoded JWT (jwt_name) in the *message type* | - | message type \| {head/body/url} \| jwt_name \| {header/payload} \| type |
| **JWT parameter values** | Verify the param*value* of a param_name located in header/payload of a decoded JWT (jwt_name) in the *message type* | - | message type \| {head/body/url} \| jwt_name \| {header/payload} \| param_name \| param_value |
| **JWT signature check** | Verify the signature of a JWT (located at jwt*name*) the *message type* | - | message type \| {head/body/url} \| jwt_name \| JWT_public_key |
| **nested JWT Check-Save to JWT** | Send a *message type* and save the value of a param*name* in a jwt_name specified with a param_path. Then verify in the *message type* that a param_jwt in the JWT (that is located at jwt_name) contains a jwt (jwt_nested_name) which contains a parameter (jwt_param_name) that has a value (saved_param) | message type \| {head/body/url} \| jwt_name \| {header/payload} \| param_path \| saved_param | message type \| {head/body/url} \| jwt_name \| {header/payload} \| param_jwt \| jwt_nested_name \| {header/payload} \| jwt_param_name \| 
| **nested JWT parameter presence** | Verify the presence of a param*name* in a nested JWT (jwt_nested_name) located at param_jwt of the jwt_name in the *message type* | - | message type \| {head/body/url} \| jwt_name \| {header/payload} \| param_jwt \| jwt_nested_name \| {header/payload} \| param_name |
| **nested JWT parameter type** | Verify that the param_value of a param_name is of a certain type (regex). The param_name is located in a jwt that is located in param of a json (json_param) in another param (jwt_nested_param) of the main jwt (jwt_name) | -  | message type \| {head/body/url} \| jwt_name \| {header/payload} \| json_param \| jwt_nested_param \| {header/payload} \| param_name.type |
| **nested JWT parameter values** | Verify that the param*value* of a param_name of a nested JWT (jwt_nested_name) located at param_jwt of the jwt_name in the *message type* is inside a list of possible values | - | message type \| {head/body/url} \| jwt_name \| {header/payload/signature} \| param_jwt \| jwt_nested_name \| {header/payload/signature} \| param_name \| ["param_value1", "param_value2", ...] |
| **nested JWT signature check** | Verify the signature of a nested JWT (jwt*nested_name*) located at param_jwt of the jwt_name in the *message type* | - | message type \| {head/body/url} \| jwt_name \| {header/payload/signature} \| param_jwt \| jwt_nested_name \| JWT_public_key |
| **Param Check-Save to JWT** | Send a *message type* and save the value of a param*name*. Then verify in another *message type* that a jwt_param_name in the JWT (that is located at jwt_name) has the param_name_value saved before | message type \| {head/body/url} \| param_name \| saved_param | message type \| {head/body/url} \| jwt_name \| {header/payload} \| jwt_param_name |
| **Param Status** | Send a *message type* with modified parameters then verify the HTTP status of another *message type* | message type \| {head/body/url} \| param_name \| param_value | message type \| {head/body/url} | HTTP_status |

### Wrong Input

| Pattern name | What we have to do | Information needed by the test | Need by the Oracle |
| ---- | ---- | ---- | ---- |
| **JWT Response** | Send a *message type* with modified parameters values in jwt*name* then verify in another *message type* the HTTP_status | message type \| {head/body/url} \| jwt_name \| {header/payload} \| param_name \| param_value \| JWT_private_key | message type \| {head/body/url} \| HTTPStatus \| {head/body/url} \| Error_code |
| **nested JWT edit** | Send a *message type* with modified parameters values in nested_param*name* in a param*name* then verify in another *message type* the HTTP_status | message type \| {head/body/url} \| param_name \| {header/payload} \| nested_param_name \| param_value | message type \| {head/body/url} \| HTTPStatus \| {head/body/url} \| Error_code |
| **Param Response** | Send a *message type* with modified parameters values then verify in another *message type* the HTTP_status | message type \| {head/body/url} \| param_name \| param_value | message type \| {head/body/url} \| HTTPStatus \| {head/body/url} \| Error_code |
| **Signature JWT Response** | Send a *message type* with modified signature of a jwt*name* then verify in the *message type* the HTTP_status | message type \| {head/body/url} \| jwt_name \| signature_value | message type \| {head/body/url} \| HTTPStatus \| {head/body/url} \| Error_code |